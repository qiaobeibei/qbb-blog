---
title: CMU-15445(6)——PROJECT#1-B+Tree-Task#1
date: 2025-05-28 10:51:40
categories:
- CMU-15445
tags: 
- Fall 2024
typora-root-url: ./..
---

# PROJECT#2-B+Tree

在 PROJECT#2 中，我们需要实现一个B plus Tree，用过 MySQL 的同学肯定对它不陌生，B+Tree是实现高效数据检索的核心组件，其内部节点的作用是引导搜索过程，而实际的数据项则存于叶子节点中。该索引结构能够实现快速的数据检索，无需对数据库表中的每一行数据进行扫描，可实现快速随机查找以及对有序记录的高效扫描。

举个例子，如果我们要用某个给定的 id 来检索某个货物的记录，没有索引结构的情况下，我们只能从第一条记录开始遍历每个货物的记录，直到找到某个ID和我们给定的ID一致的记录，时间复杂度是O(N)。常见的索引结构有二叉树、红黑树、哈希表和B+Tree，而如果我们维护了一个以ID为KEY的索引结构，我们可以通过这个索引结构查询这个ID对应的货物所在的位置，然后直接从这个位置读取数据，B+Tree能保证 O (log n) 时间复杂度的检索操作。

在着手项目开发前，建议先系统学习 B + 树数据结构的核心原理，预先夯实知识基础。

## B+Tree

DB 的数据一般保存在磁盘上，这样的好处是持久化，但也有很大的缺点：**读写特别慢**。

磁盘读写的最小单位是**扇区**，扇区的大小只有 `512B` 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是**块**(Block)。Linux 中的块（页）大小为 `4KB` ，也就是一次磁盘 I/0 操作会直接读写8个扇区。

由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先**从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存**，也就是说查询过程中会发生多次磁盘//O，而磁盘 I/0 次数越多，所消耗的时间也就越大（如果没有索引结构，那么就需要从头开始将每一行数据的索引从磁盘读到内存和目标索引进行对比，I/O次数会特别多）。

所以，我们希望索引的数据结构能在尽可能少的磁盘的 1/0 操作中完成查询工作，因为磁盘 I/0 操作越少，所消耗的时间也就越小。

因此，一个合格的数据结构需要满足以下要求：

- 能在尽可能**少**的磁盘的 /O 操作中完成查询工作；
- 要能高效地查询**某一个记录**，也要能高效地执行**范围查找**;

如果可以将索引按顺序（增序或降序），那么可以通过二分查找来降低查询时间复杂度到O(logN)，进一步优化到二分查找树、自平衡二叉树、B树....，这一部分内容可参考文章：

[>>>为什么 MySQL 采用 B+ 树作为索引？ | 小林coding<<<](https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html#什么是二分查找)

索引结构的迭代优化总结起来其实就是以下内容：

在数据结构的索引场景中，若将索引存储于数组结构，线性查找的时间复杂度为 O (N)，而采用二分查找可将复杂度降至 O (logN)。尽管数组的线性存储方式实现简单，但插入操作需移动后续所有元素，导致 O (N) 级的时间开销。由此引出二叉树结构，其通过指针链接节点实现非连续存储，兼具二分查找特性，但当二叉搜索树退化为单支树（如全右子树或全左子树）时，时间复杂度会退化为 O (N)。

为解决此类平衡性问题，AVL 树与红黑树等平衡二叉搜索树应运而生。然而，无论何种平衡树结构，其树高仍随数据量呈 O (logN) 增长，这直接导致磁盘 I/O 次数随树高增加而显著上升。B 树的出现通过提升节点扇出能力（单个节点可包含多个子节点）有效降低树高，但传统 B 树节点存储索引与数据记录的复合信息，当用户数据记录尺寸远大于索引键时，会引发两大问题：

1. 非目标节点的数据记录加载会消耗额外 I/O 资源；
2. 无效数据占用内存空间，降低缓存命中率。

B+树其实就是B树的升级，MySQL 中索引的数据结构就是采用了 B+ 树，B+ 树结构如下图：

![图片](/images/$%7Bfiilename%7D/b6678c667053a356f46fc5691d2f5878.png)

<center>图片来源：https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html#%E4%BB%80%E4%B9%88%E6%98%AF-b-%E6%A0%91-2</center>

B+ 树与 B 树差异的点，主要是以下这几点：

- 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；
- 所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；
- 非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。
- 非叶子节点中有多少个子节点，就有多少个索引；



![image-20250528115452211](/images/$%7Bfiilename%7D/image-20250528115452211.png)



参考：[为什么 MySQL 采用 B+ 树作为索引？ | 小林coding](https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html#什么是-b-树-2)

## TASK#1-B+Tree Pages

未完待续。。。
