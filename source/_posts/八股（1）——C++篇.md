---
title： 八股（1）——C++篇
date： 2025-02-25 22：07：31
categories：
- 八股
typora-root-url:./..
---

# 1. C++基础

## 1.1 指针和引用的区别  

- **指针**存放某个对象的地址，其本身就是变量（命了名的对象），本身就有地址，所以可以有指向指针的指针；可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变  
- **引⽤**就是变量的别名， 从⼀⽽终，不可变，必须初始化  
- 不存在指向空值的引⽤，但是存在指向空值的指针  
- 从**编译的角度**来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值(与实参名字不同，地址相同)。**符号表生成之后就不会再改**，**因此指针可以改变其指向的对象(指针变量中的值可以改)，而引用对象则不能修改**。

## 1.2 C++ 中的指针参数传递和引用参数传递  

指针参数传递本质上是**值传递**，它所传递的是一个地址值。值传递过程中，被调函数的形参作为被调函数的**局部变量**处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本。值传递的特点是，被调函数对形参的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值实参指针不会变)。但我们可以通过解引用`*`来修改指针所指向对象的值。

引用参数传递过程中，被调函数的形参也作为**局部变量**在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的**实参变量的地址**。被调函数对形参(本体)的任何操作都被处理成**间接寻址**，即通过栈中存放的地址访问主调函数中的实参变量。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

**引用传递和指针传递是不同的**，虽然他们都是在被调函数栈空间上的一个**局部变量**，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量(地址)，那就得使用**指向指针的指针**或者**指针引用**。

从**编译的角度**来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值(与实参名字不同，地址相同)。**符号表生成之后就不会再改**，**因此指针可以改变其指向的对象(指针变量中的值可以改)，而引用对象则不能修改**。

## 1.3 关键字

### 1.3.1 const

- `const`的作用：被它修饰的值不能改变，是**只读变量**，且必须在定义的时候就给它赋初值。
- 作用域：由声明位置决定
- 存储期：不会影响变量的存储期

需要注意的是：

- 常量指针（`const int* a = &temp`或`int const *a = &temp`，也叫`底层const`）表示这个指针指向⼀个只读的对象，**不能通过常量指针来改变这个对象的值 ，但我们可以改变这个指针所指向的对象**。
- 指针常量（`int* const p = &temp` ，也叫`顶层cons`t）表示这个指针的值只能在定义时初始化，其他地⽅不能改变。指针常量强调的是指针的不可改变性，即**我们不能改变这个指针所指向的对象，但可以改变所指向对象的值**。

- const 在类中的用法：`const 成员变量`，只在实例的生命周期内是常量，而对于整个类而言是可以改变的。因为类可以创建多个实例，不同的实例其 const 数据成员值可以不同。所以**不能在类的声明中初始化 const 数据成员**，因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么。const 数据成员的初始化只能在类的构造函数的初始化列表中进行。
- const 成员函数：const 成员函数的主要目的是防止成员函数修改对象的内容。要注意，const 关键字和 static 关键字对于成员函数来说是**不能同时使用**的，因为 static 关键字修饰静态成员函数不含有 this 指针，即不能实例化，const 成员函数又必须具体到某一个函数
  - **`this`指针冲突**：当`const`修饰成员函数时，C++ 编译器为确保函数不会修改对象状态，会在函数中隐式**添加一个`this`指针**（`类名 const * const this`，this指针既不能改变指向对象，也不能改变指向对象的值），这个指针指向调用函数的对象（类的实例），且既不能改变指向对象的地址，也不能通过它修改对象的值（实例的成员变量）。而`static`修饰的成员函数属于类本身，并不属于类的某个对象，调用时不依赖类的实例，所以**没有`this`指针** 。两者在`this`指针的处理上是冲突的。
  - **语意矛盾**：`static`修饰成员函数时，表明该函数只作用于类的静态变量，和类的实例没有关系；而`const`修饰成员函数是为了保证函数不会修改类实例的状态，关注的是类的实例，和类的静态变量无关。二者含义相互矛盾，所以不能同时使用。
- const 修饰类对象，定义常量对象：常量类对象只能调用常量函数，别的成员函数都不能调用。
  - 原因：常量类对象一旦创建，里面的值（成员变量）就不能被修改。比如一个 “不可修改的学生” 对象，它的姓名、年龄等信息都不能被改变。而在`非const成员函数`中，函数内部有可能改变对象的值，这对常量对象是不允许的，所以常量对象不能调用非`const`成员函数，只能调用`const成员函数`。
  - const 成员函数中如果实在想修改某个变量，可以使用 mutable 进行修饰成员变量。成员变量中如果想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现或者 static const。

### 1.3.2 static

`static` 关键字主要用于控制变量和函数的**生命周期、作用域以及访问权限**。

- 修饰局部变量：一般情况下，对于局部变量在程序中是**存放在栈区**的，并且局部的生命周期在包含语句块执行结束时便结束了。但是如果用 static 关键字修饰的话，该变量便会**存放在静态数据区**，**其生命周期会一直延续到整个程序执行结束**。但是要注意的是，虽然用static 对局部变量进行修饰之后，其生命周期以及存储空间发生了变化，但其作用域并没有改变，作用域还是限制在其语句块。
- 修饰全局变量：对于一个全局变量，它既可以在本文件中被访问到，也可以在同一个工程中其它源文件被访问(添加 extern进行声明即可)。**用 static 对全局变量进行修饰改变了其作用域范围**，由原来的整个工程可见变成了本文件可见。
- 修饰函数：用 static 修饰函数，情况和修饰全局变量类似，也是改变了函数的作用域。
- 修饰成员函数：属于类而不是类的实例，可以**通过类名直接调用**，而无需创建对象。**静态成员函数不能直接访问非静态成员变量或非静态成员函数。**
- 修饰类：如果C++ 中对类中的某个函数用 static 修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行 static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在一个副本，可以通过`::`类和对象去调用。
  - 静态非常量数据成员，其只能在类外定义和初始化，在类内仅是声明 。static 修饰的变量先于类的对象存在，所以 static 修饰的变量要在类外初始化；  
- static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 vrtual 没有任何实际意义；**静态成员函数没有 this 指针**，虚函数的实现是为每一个对象分配一个 vptr 指针，而 vptr 是通过 this 指针调用的，所以不能加 virtual；虚函数的调用关系，this->vptr->ctable（虚表）->virtual function。

### 1.3.3 define 和 typedef 的区别  

**含义与功能**：

- `define`在C 和 C++ **编译的预处理阶段起作用**，主要用于进行简单的文本替换，也称为宏定义，**没有类型检查**。它可以用来定义常量、函数式宏等。例如，`#define PI 3.14159` 定义了一个名为`PI`的宏，在预处理阶段，所有出现`PI`的地方都会被替换为`3.14159`。**define 定义的宏不会分配内存**，给出的是立即数，代码中有多少地方使用宏就会进行多少次替换。

- `typedef`是 C 和 C++ 中的关键字，用于为已存在的数据类型定义一个新的别名，用来增强代码的可读性和可维护性。例如，`typedef int MyInt；` 定义了`MyInt`作为`int`类型的别名，之后就可以使用`MyInt`来声明变量，就像使用`int`一样。

  但`typedef`定义的别名与原类型在本质上是同一种类型，在编译时会**进行严格的类型检查**，主要在**编译、运行时起作用**。

  在静态存储区中分配空间，在程序运⾏过程中内存中只有⼀个拷贝。

### 1.3.4 inline

- 当函数被声明为`inline`时，编译器会尝试在调用该函数的地方将函数代码直接展开，而不是进行常规的函数调用操作。这样可以避免函数调用时保存现场、传递参数、跳转执行等操作带来的开销，提高程序的执行效率。

  - 常规函数调用时，先按值传递、指针传递或引用传递方式，将实参传给形参，在**栈上为参数分配空间**并处理数据；

    接着保存当前程序执行状态，包括程序计数器(记录程序执行到的位置)和寄存器的值，把这些信息**压入栈**（这些信息将在函数执行完毕后用于恢复程序的执行状态，以便继续执行调用函数之后的代码）；

    然后修改程序计数器，跳转至被调用函数入口执行函数体，函数体内处理参数、定义和使用局部变量；执行完毕，按返回类型把返回值存到指定位置，再从栈中弹出之前保存的寄存器值和程序计数器值，恢复到调用前状态，最后依据恢复后的程序计数器值，继续执行调用函数之后的代码 。

- 在 C++ 中，如果在多个源文件中定义了同名的全局变量，链接时会出现冲突。而使用`inline`修饰全局变量，就可以在多个源文件中都定义这个变量，但实际上只会有一份变量的实例被创建，链接器会将这些同名的`inline`变量合并为一个。

### 1.3.5 const和define的区别

`const`用于定义常量；而`define`用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：

1. `const`生效于**编译**的阶段；`define`生效于**预处理**阶段。
2. `const`定义的常量，在C语言中是**存储在内存**中、需要额外的内存空间的；`define`定义的常量，运行时是直接2的操作数，并**不会分配内存**
3. `const`定义的常量是**带类型**的；`define`定义的常量**不带类型**。

### 1.3.6 new 和 malloc的区别  

1. `new`内存分配失败时，会抛出`bac_alloc`异常，它不会返回`NULL`；`malloc`分配内存失败时返回`NULL`。

2. 使用new操作符申请内存分配时无须指定内存块的大小，而`malloc`则需要显式地指出所需内存的尺寸。

3. `opeartor new /operator delete`可以被重载，而`malloc/free`并不允许重载，**因为`new/delete`是操作符，而`malloc/free`是库函数。**

4. `new/delete`会调用对象的构造函数/析构函数以完成对象的构造/析构，而`malloc`则不会。所以`new`和`delete`的执行都是两步，分配空间->调用构造函数；或者调用析构函数->回收空间。

5. `malloc`与`free`是C++/C语言的标准库函数，`new/delete`是C++的运算符

6. `new`操作符从**自由存储区**（当程序运行时，操作系统会为程序分配一块**堆内存空间**，自由存储区就存在于这个堆空间之中，但只有`new`才能分配）上为对象动态分配内存空间，而`malloc`函数从**堆**上动态分配内存。

7. 为什么有了 `malloc/free` 还需要 `new/delete`？

   针对非内部数据类型而言，比如自定义的类，它们在创建时不仅需要分配内存，还必须自动执行构造函数来完成初始化工作；在对象生命周期结束时，需要执行析构函数来释放资源、清理内存等。`malloc/free`作为库函数，并不在编译器的直接控制范围内，编译器无法强制它们在分配和释放内存时自动调用构造函数与析构函数。而`new/delete`是 C++ 的运算符，编译器能够对其进行有效管控，从而确保在创建和销毁对象时，构造函数与析构函数得以正确执行，满足了动态对象全面的管理需求，所以`new/delete`对于 C++ 的面向对象编程至关重要。

### 1.3.7 const和volatile的区别

**作用：**

- **`const`**：表示常量，用于修饰变量、函数参数和函数返回值等，表明被修饰的对象的值在初始化后不能被修改，是一种编译时的限定。使用`const`可以让编译器进行类型检查，防止意外地修改常量值，增强程序的健壮性和可读性。
- **`volatile`**：表示易变的，用于告诉编译器，**被修饰的变量可能会在程序的控制流之外被改变**，即变量的值可能会在编译器意想不到的情况下发生变化，比如来自硬件的异步操作或多线程环境中的其他线程。这会**使编译器不对该变量进行优化**，以确保每次访问该变量时都从内存中读取最新的值，而不是使用可能已经缓存的旧值（寄存器）。

**内存访问：**

- **`const`**：对于`const`修饰的变量，如果编译器能够确定其值不会改变，可能会将其**缓存在寄存器**中，以提高访问速度。因为编译器认为在程序执行过程中该值始终保持不变，所以可以直接从寄存器中读取，而不需要每次都从内存中获取。
- **`volatile`**：`volatile`修饰的变量则相反，编译器会严格按照从内存中读取和写入的方式来处理对该变量的访问，即使编译器可能认为从优化的角度可以使用缓存的值，也会**强制去内存中获取最新的值**，以保证程序能够正确处理变量的意外变化。

**举例：**

```cpp
for(volatile int i=0; i<100000; i++){}; // 它会执⾏，不会被优化掉
```

如果不用 volatile 进行修饰，编译器会认为这段代码是空循环，会将其优化。

### 1.3.8 前置++与后置++  

运算顺序：

- **前置 ++**：先将变量的值增加 1，然后再使用变量的新值进行表达式的计算。例如在`int a = 5; int b = ++a;`中，先将`a`的值自增为 6，然后再将`a`的新值 6 赋给`b`，最终`a`和`b`的值都为 6。
- **后置 ++**：先使用变量原来的值进行表达式的计算，然后再将变量的值增加 1。例如在`int a = 5; int b = a++;`中，先将`a`的值 5 赋给`b`，然后`a`的值再自增为 6，最终`a`的值为 6，`b`的值为 5。

返回值：

- **前置 ++**：返回的是**自增后变量的引用**。这意味着可以将前置自增的结果继续作为左值使用，即可以对其进行赋值等操作。例如`int a = 5; (++a) = 10;`是合法的，最终`a`的值为 10。
- **后置 ++**：返回的是变量**自增前的原始值的副本**。由于返回的是副本，所以后置自增的结果不能作为左值使用。例如`int a = 5; (a++) = 10;`是不合法的，会导致编译错误。

举例：

```cpp
double arr[5] = {21.2, 32.8, 23.4, 2, 47.43};
double* pt = arr;
cout << *pt; // 21.2
cout << *++pt; 32.8
cout << ++*pt; 33.8;
cout << (*pt)++; //33.8
cout << *pt; // 34.8;
cout << *pt++; // 34.8
cout << *pt; //23.4
```

### 1.3.9 explicit

C++中的`explicit`关键字只能用于修饰**只有一个参数的类构造函数，**它的作用是表明该构造函数是显式的，而非隐式的，跟它相对应的另一个关键字是`implicit`，意思是隐藏的，类构造函数默认情况下即声明为`implicit`(隐式)。

假如有如下类：

```cpp
class CxString  // 没有使用explicit关键字的类声明, 即默认为隐式声明  
{  
public:  
    char *_pstr;  
    int _size;  
    CxString(int size)  
    {  
       ....... 
    }  
    CxString(const char *p)  
    {  
        ......
    }  
}; 
```

我们对其进行测试：

```cpp
    CxString string1(24);     // 这样是OK的, 为CxString预分配24字节的大小的内存  
    CxString string2 = 10;    // 这样是OK的, 为CxString预分配10字节的大小的内存  
    CxString string4("aaaa"); // 这样是OK的  
    CxString string5 = "bbb"; // 这样也是OK的, 调用的是CxString(const char *p)  
    CxString string6 = 'c';   // 这样也是OK的, 其实调用的是CxString(int size), 且size等于'c'的ascii码  
    string1 = 2;              // 这样也是OK的, 为CxString预分配2字节的大小的内存  
    string2 = 3;              // 这样也是OK的, 为CxString预分配3字节的大小的内存  
    string3 = string1;        // 这样也是OK的, 至少编译是没问题的, 但是如果析构函数里用free释放_pstr内存指针的时候可能会报错, 完整的代码必须重载运算符"=", 并在其中处理内存释放  
```

上面的代码中， `"CxString string2 = 10"` 这句为什么是可以的呢? 在C++中，如果的构造函数只有一个参数时, 那么在编译的时候就会有一个缺省的转换操作：**将该构造函数对应数据类型的数据转换为该类对象**。 也就是说 `"CxString string2 = 10;"` 这段代码,，编译器自动将整型转换为`CxString`类对象，实际上等同于下面的操作:

```cpp
CxString string2(10);  
或  
CxString temp(10);  
CxString string2 = temp; 
```

不过注意，只有当该变量类型和只有一个参数构造函数形参的**类型相同**时才能发生隐式转换。

### 1.3.10 final 和 override

借由虚函数实现运行时多态，但C++的虚函数又很多脆弱的地方：

- 无法禁止子类重写它。可能到某一层级时，我们不希望子类继续来重写当前虚函数了。
- 容易不小心隐藏父类的虚函数。比如在重写时，不小心声明了一个签名不一致但有同样名称的新函数。

C++11 提供了 `final` 来禁止虚函数被重写/禁止类被继承，`override` 来显式地重写虚函数。这样编译器给我们不小心的行为提供更多有用的错误和警告。

## 1.4 C和C++的区别（函数/类/struct/class）

- 语言性质：C是面向过程编程，而C++是面向对象编程
- 类和对象：
  - C语言：没有类和对象的概念，主要通过结构体来组织数据和相关操作函数，但结构体只是数据的集合，不具备面向对象编程中类的**封装、继承和多态**等特性。默认成员访问权限和继承权限是`public`。
  - C++：引入了类的概念，将数据和操作数据的方法封装在类中，通过创建类的对象来访问和操作这些数据和方法，支持面向对象编程的三大特性：**封装、继承和多态**。默认成员访问权限和继承权限是`private`。
- 函数重载：
  - **C 语言**：不支持函数重载，并且没有虚函数的概念。
  - **C++**：支持函数重载，且支持多态。
  - C不支持重载的原因：因为C++ 函数的名字修饰与C不同，**C++ 函数名字的修饰会将参数加在后面**，例如，int func(int,double)经过名字修饰之后会变成_func_int_double，这样即使同名函数但在编译器编译和链接时都会有唯一一个内部名称用于分别重载函数；而C中则会变成 func，所有同名函数共用一个名称，所以 C++ 中会支持不同参数调用不同函数。

## 1.5 说⼀下 C++ 是怎么定义常量的？常量存放在内存的哪个位置？  

定义常量一般使用两种方式：`const`关键字修饰或`#define`预处理指令。

- **全局常量和静态常量**：全局作用域中定义的常量以及类中的静态常量，如果是基本数据类型且值在编译时可确定，通常会存储在全局静态区（.data）中。这部分内存区域在程序运行期间是**只读**的，防止程序意外修改常量的值。
- **局部常量**：一般存储在栈区，当超出作用域范围后，栈上的空间会被释放。
- **用`new`动态分配的常量**：通过`new`关键字动态分配内存创建的常量，会存储在**堆区中的自由存储区**中。

## 1.6 C++ 中重载、重写和重定义的区别  

- 重载：指同⼀可访问区内被声明的⼏个具有**不同参数列表**的同名函数，依赖于 C++函数名字的修饰会将参数加在后⾯（每个函数都有自己的内部名称，即使外部同名，但内部名字仍然不同），可以是参数类型，个数，顺序的不同。根据参数列表决定调⽤哪个函数，重载**不关⼼函数的返回类型**。  
- 重写：派生类中重新定义父类中**除函数体外完全相同的虚函数**，注意被重写的函数不能是 static 的，**一定要是虚函数**（static和virtual不能共用，static没有this指针，而虚函数的调用需要this指针），且其他一定要完全相同。要注意，重写和被重写的函数是在不同的类当中的，重写函数的访问修饰符是可以不同的，尽管 virtual 中是 private 的，派生类中重写可以改为 public。
- 重定义(隐藏)：派生类重新定义父类中相**同名**字的**非 virtual 函数**；参数列表和返回类型**都可以不同**，即父类中除了定义成 virtual 且完全相同的同名函数才不会被派生类中的同名函数所隐藏(重定义)。

## 1.7 C++ 的四种强制转换  

C++ 的四种强制转换分别是`static_cast`、`reinterpret_cast`、`const_cast`和`dynamic_cast`：

- **`static_cast`**：用于具有**明确定义的类型转换**，在使用时最好明确指出类型转换，如基本数据类型之间的转换，以及有继承关系的类之间的指针或引用转换。但不能用于去除`const`等常量属性，也**不**能在不相关的类型之间进行转换，比如指针和int，两个没有继承关系的类之间就不可以转换。上行转换(派生类->基类)安全，下行转换(基类->派生类)不安全。
- **`dynamic_cast`**：主要用于在**有继承关系的类之间进行安全的向下转型**，即从基类指针或引用转换为派生类指针或引用。它在运行时进行类型检查，如果转换失败，对于指针类型会返回`nullptr`，对于引用类型会抛出`std::bad_cast`异常，常用于多态场景下确定对象的实际类型。
- **`reinterpret_cast`**：主要用于将一种**指针类型转换为另一种完全不同的指针类型**，或者将整数类型与指针类型进行转换，它是最底层的、最不安全的转换方式，可能会导致不可预测的结果，应谨慎使用。比如将`int*`转成`char*`。
- **`const_cast`**：专门用于**去除对象的`const`或`volatile`属性**，使原本只读的对象可以被修改，但如果对一个真正的常量进行这种操作，会导致未定义行为。常用于函数需要修改传入的`const`对象的场景。

## 1.8 函数指针  

从定义和用途两方面来说一下自己的理解：

- 首先是定义：函数指针是指向函数的指针变量。函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数，存储函数的地址。
  在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。
- 其次是用途：**调用函数**和**做函数的参数**，比如回调函数。

```cpp
int add(int a, int b) {
	return a + b;
}
int subtract(int a, int b) {
	return a - b;
}
int main() {
	// 定义⼀个函数指针，指向⼀个接受两个int参数、返回int的函数
	int (*operationPtr)(int, int);
    // 初始化函数指针，使其指向 add 函数
    operationPtr = &add;
    // 通过函数指针调⽤函数
    int result = operationPtr(10, 5);
    cout << "Result: " << result << endl;
    // 将函数指针切换到 subtract 函数
    operationPtr = &subtract;
    // 再次通过函数指针调⽤函数
    result = operationPtr(10, 5);
    return 0;
}
```

> 注意区分函数指针和指针函数的区别：前者是指向函数的**指针**变量 ，后者是⼀个返回指针类型的**函数**，⽤于返回指向某种类型的数据的指针 。

## 1.9 封装、继承、多态  、虚函数表、联编、纯虚函数

[设计模式（1）——面向对象和面向过程，封装、继承和多态 | 爱吃土豆的个人博客](https://www.aichitudou.cn/2025/01/07/设计模式（1）——面向对象和面向过程，封装、继承和多态/)

## 1.10 编译器如何处理虚函数表  

对于派生类来说，编译器建立虚函数表一共有三个步骤：

**第一步：拷贝基类虚函数表**：

若派生类是单继承，编译器会直接拷贝基类的虚函数表；要是多继承的情况，编译器会拷贝每个含有虚函数的基类的虚函数表。这里存在一种特殊情形，即可能有某个基类的虚函数表和派生类自身的虚函数表共用一个，此基类被称作派生类的主基类。

**第二步：替换重写的虚函数地址**：

编译器会检查派生类中是否存在重写基类虚函数的情况。若有，就会把虚函数表中对应基类虚函数的地址，替换为派生类中重写后的虚函数地址。这一操作能保证在运行时，当通过基类指针或引用调用虚函数时，实际调用的是派生类中重写后的版本。

**第三步：追加派生类自身的虚函数**：

编译器会查看派生类是否定义了自身特有的虚函数。若存在，就会将这些派生类自身的虚函数地址追加到派生类的虚函数表中。如此一来，当调用这些派生类特有的虚函数时，就能正确地找到对应的函数实现。

![image-20250226150826017](/images/$%7Bfiilename%7D/image-20250226150826017.png)

## 1.11 析构函数⼀般写成虚函数的原因  

**为了降低内存泄漏的可能性**。

举例来说就是，一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数 (该对象的析构函数的函数地址早就被绑定为基类的析构函数)，仅执行基类的析构，派生类的自身内容将无法被析构，造成内存泄漏。

如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执行派生类的析构函数，再执行基类的析构函数，成功释放内存。

## 1.12 构造函数为什么⼀般不定义为虚函数  

虚函数调用只需要知道“部分的"信息，即只需要知道函数接口，而不需要知道对象的具体类型。但是，我们要创建一个对象的话，是需要知道对象的完整信息的。特别是，需要知道要创建对象的确切类型，因此，构造函数不应该被定义成虚函数；

而且从目前编译器实现虚函数进行多态的方式来看，虚函数的调用是通过**实例化之后**对象的虚函数表指针来找到虚函数的地址进行调用的，如果说构造函数是虚的，那么虚函数表指针则是不存在的（因为构造函数是虚的，那么同样需要虚函数表来进行调用，但是虚函数表只有在调用构造函数之后才会生成，自相矛盾了），无法找到对应的虚函数表来调用虚函数，那么这个调用实际上也是违反了先实例化后调用的准则。

## 1.13 构造函数或析构函数中调用虚函数会怎样

在构造函数或析构函数中调用虚函数**不会展现出多态特性**。

- 当在构造函数中调用虚函数时，调用的是当前构造函数所属类的虚函数版本，而不是派生类重写的版本。这是因为在构造派生类对象时，会先调用基类的构造函数，此时派生类部分还未完全构造好（**派生类的虚函数表还未形成，无法调用派生类的虚函数**），编译器只能保证基类部分是有效的，所以调用虚函数时只能调用基类的版本
- 在析构函数中调用虚函数，调用的同样是当前析构函数所属类的虚函数版本。这是因为在销毁派生类对象时，会先调用派生类的析构函数，之后再调用基类的析构函数，当进入基类析构函数时，派生类部分已经被销毁，此时只能调用基类的虚函数版本。

## 1.14 构造函数的析构函数的执行顺序

**构造函数顺序**：

- 首先调用基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中**出现的顺序**，而不是它们在成初始化表中的顺序。
- 然后调用成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中**被声明的顺序**，而不是它出现在成员初始化表中的顺序。
- 最后调用派生类构造函数。

**析构函数顺序**：

- 调用派生类的析构函数;
- 调用成员类对象的析构函数;
- 调用基类的析构函数。

## 1.15 深拷贝和浅拷贝  

当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数-即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。

但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针指向同一个地址，当对象快要结束时，会调用两次析构函数，而导致指野指针的问题。

所以，这时必需采用深拷贝。深拷贝与浅拷贝之间的区别就在于**深拷贝会在堆内存中另外申请空间来存储数据，从而也就解决来野指针的问题**。简而言之，当数据成员中有指针时，必需要用深拷贝更加安全。

## 1.16 什么情况下会调用拷贝构造函数(三种情况)  

类的对象需要拷贝时，**拷贝构造函数**（不是默认构造）将会被调用，以下的情况都会调用拷贝构造函数:

- 一个对象以值传递的方式传入函数体，需要拷贝构造函数创建一个临时对象压入到栈空间中。
- 一个对象以值传递的方式从函数返回，需要执行拷贝构造函数创建一个临时对象作为返回值。
- 一个对象需要通过另外一个对象进行初始化。

## 1.17 为什么拷贝构造函数必须加const &?

为了防止递归调用。当一个对象需要以值方式进行传递时，编译器会生成代码调用它的拷贝构造函数生成一个副本，如果类A的拷贝构造函数的参数不是引用传递，而是采用值传递，那么就又需要为了创建传递给拷贝构造函数的参数的临时对象，而又一次调用类 A的拷贝构造函数，这就是一个无限递归。

**1) 拷贝构造函数的标准写法**: 通常情况下，拷贝构造函数的声明为：

```cpp
ClassName(const ClassName& other);
```

这样可以避免在传递对象时进行额外的拷贝操作，因为参数是以引用的方式传递的

**2) 传值方式的拷贝构造函数**: 如果不加 &，而是像这样声明：

```cpp
ClassName(ClassName other);
```

这意味着拷贝构造函数的参数是按值传递的。按值传递要求创建一个临时的拷贝，这就需要再次调用拷贝构造函数来创建这个参数的拷贝

**无限递归**: 当拷贝构造函数以按值传递的方式声明时，每次调用拷贝构造函数都会再次调用自己来创建参数的拷贝，导致无限递归。这样会导致程序崩溃（栈溢出）

**自己拷贝自己**：此外，在实现**拷贝赋值运算符**时，如果对象不小心将自己作为右值传入，就会发生“自己拷贝自己”的情况。常见的做法是在赋值前检查是否是“自己拷贝自己”，如下所示：

```cpp
ClassName& operator=(const ClassName& other) {
    if (this == &other) {
        return *this;  // 如果是自己拷贝自己，则直接返回，避免后续操作
    }

    return *this;
}
```

## 1.18 预处理，编译，汇编，链接程序的区别  

一段高级语言代码需要经过四个阶段的处理，最终形成可执行的目标二进制代码。这四个阶段依次为：**预处理器→编译器→汇编器→链接器。**

- **预处理阶段**：当我们编写好如 `hello.c` 这样的高级语言程序文本后，预处理器会依据以 `#` 开头的命令对原始程序进行修改。例如，`#include <stdio.h>` 指令会将系统中的头文件插入到程序文本里，预处理后的文件通常以 `.i` 结尾。
- **编译阶段**：编译器会把 `hello.i` 文件翻译成文本文件 `hello.s`，这是一个汇编语言程序。需要注意区分概念，高级语言编写的是源程序，而汇编语言程序的每条语句都以标准的文本格式精确描述一条低级机器语言指令。不同的高级语言经过编译后可能会生成相同的汇编语言程序。
- **汇编阶段**：汇编器会把 `hello.s` 文件翻译成机器语言指令，并将这些指令打包成可重定位目标程序，也就是 `.o` 文件。`hello.o` 是一个二进制文件，其字节码为机器语言指令，不再是字符形式，而前两个阶段处理后的文件仍包含字符。
- **链接阶段**：以 `hello` 程序为例，若它调用了 `printf` 函数，这是每个 C 编译器都会提供的标准库 C 中的函数，该函数存在于一个单独编译好的目标文件 `printf.o` 中。**链接器的作用就是将 `printf.o` 以某种方式合并到 `hello.o` 中，最终得到可执行目标文件**。

## 1.19 动态编译与静态编译  

**静态编译**：

- **原理**：在静态编译过程中，编译器会将程序所依赖的所有库文件（如函数库等）的代码都完整地包含到最终生成的可执行文件中。也就是说，可执行文件包含了运行所需的全部代码，不依赖外部的库文件来提供功能。
- **优点**：可移植性强，因为可执行文件自身包含了所有必要的代码，在任何支持该平台的环境中都可以直接运行，无需额外安装依赖库。
- **缺点**：生成的可执行文件体积较大，因为包含了大量的库代码；而且如果库文件更新，需要重新进行编译。

**动态编译**：

- **原理**：动态编译生成的可执行文件并不包含所依赖库的完整代码，而是在程序运行时才去加载所需的动态链接库（`DLL`，在 Windows 系统中）或共享对象文件（`.so`，在 Linux 系统中）。这些动态库可以被多个程序共享使用。
- **优点**：生成的可执行文件体积较小，因为不包含库的代码；并且库文件更新时，只要接口不变，可执行文件无需重新编译就能使用新的库功能。
- **缺点**：程序运行依赖于系统中存在相应的动态库，如果缺少这些库，程序将无法正常运行，这在一定程度上降低了程序的可移植性。

## 1.20 动态链接和静态链接

**静态链接**库就是把(lib) 文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；**动态链接**就是把调用的函数所在文件模块(DLL)和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从 DLL 中寻找相应函数代码，因此需要相应 DLL 文件的支持。

静态链接库与动态链接库**都是共享代码**的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都**全部**被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。

静态链接库和动态链接库的另外一个区别在于**要包含的静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。**

动态库就是在需要调用其中的函数时，根据**函数映射表**找到该函数然后调入堆栈执行。如果在当前工程中有多处对`.dll`文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但如果有多处对 `.lib` 文件中同一个函数的调用，那么执行时该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。

## 1.21 动态联编与静态联编 

[设计模式（1）——面向对象和面向过程，封装、继承和多态 | 爱吃土豆的个人博客](https://www.aichitudou.cn/2025/01/07/设计模式（1）——面向对象和面向过程，封装、继承和多态/#2-3-7-动态联编和静态联编)

## 1.22 构造函数、析构函数可否抛出异常  

**构造函数**允许抛出异常。在构造对象的过程中，可能会遇到各种错误情况，比如内存分配失败、文件打开失败、网络连接失败等，此时可以通过抛出异常来通知调用者对象构造失败。

- **对象构造未完成**：一旦构造函数抛出异常，对象的构造过程就会终止，已经分配的部分资源会被正确释放（如果在抛出异常前有相应的资源管理机制），并且对象不会被创建成功。
- **局部对象的析构**：如果构造函数在初始化列表或者函数体中创建了局部对象，当构造函数抛出异常时，这些已经成功构造的局部对象会按照与构造顺序相反的顺序自动调用析构函数进行析构。

**析构函数**通常不应该抛出异常。

- **可能导致程序崩溃**：如果析构函数抛出异常，并且在异常处理过程中又有其他异常抛出（例如，在析构过程中调用的其他函数也抛出异常），会导致程序进入未定义行为，很可能会使程序崩溃。
- **异常安全问题**：在对象销毁的过程中，通常是为了释放资源，如果析构函数抛出异常，可能会导致部分资源无法正确释放，从而引发资源泄漏。

- **必须抛出异常时**：如果析构函数中确实可能会出现异常情况，可以在析构函数内部捕获异常并进行处理，而不是将异常抛出。

## 1.23 何时需要成员初始化列表？过程是什么？  

- 当对引用成员变量进行初始化时；
- 当对 `const` 成员变量进行初始化时；
- 成员变量是一个禁止拷贝的变量时；成员初始化列表是在**对象构造时直接进行初始化，避免了赋值和拷贝的过程**，所以可以用于初始化禁止拷贝的变量。
- 当调用基类的构造函数，且该构造函数带有一组参数时；
- 当调用成员类的构造函数，且该构造函数带有一组参数时；

编译器会对初始化列表进行处理，它会按照恰当的顺序，在构造函数内部插入初始化操作，并且这些操作会在任何用户显式编写的代码之前执行。需要注意的是，初始化列表中项目的执行顺序是由**类中成员的声明顺序**所决定的，而非初始化列表里的排列顺序。

## 1.24 程序员定义的析构函数被扩展的过程

在 C++ 中，程序员定义的析构函数在编译阶段会被编译器进行扩展，以确保对象在销毁时能正确处理各种资源和执行必要的操作。

**1. 执行用户自定义的析构函数代码**

执行析构函数内部代码

**2. 调用成员对象的析构函数**

如果类包含成员对象，编译器会在用户自定义的析构函数代码之后，按照成员对象在类中声明的相反顺序调用它们的析构函数。这是为了确保成员对象的资源能够被正确释放。

**3.如果对象有⼀个 vptr，会被重新新定义**  

当对象开始析构时，在执行用户自定义的析构函数代码之前，编译器会确保 vptr 仍然指向当前对象实际类型对应的虚函数表。这是因为在析构的早期阶段，对象仍然是完整的，其行为应该遵循当前类型的定义。

随着析构过程的推进，当成员对象和基类部分开始析构时，vptr 会逐步调整。**在调用成员对象的析构函数时**，vptr 不会改变，因为此时对象的主要类型特性还是当前类。**当开始调用基类的析构函数时**，vptr 会被调整为指向基类的虚函数表。这是因为在基类析构期间，对象的派生类部分已经被销毁，对象的行为应该遵循基类的定义。例如，在一个多层继承体系中，当从派生类析构进入基类析构时，vptr 会从指向派生类虚函数表切换到指向基类虚函数表，以保证在基类析构函数中调用虚函数时，调用的是基类版本的函数。

**4. 调用基类的析构函数**

如果类是派生类，编译器会在成员对象的析构函数调用之后，调用其直接基类的析构函数。如果基类还有基类，会按照继承层次从下往上依次调用各级基类的析构函数

**5. 释放对象占用的内存**

在完成上述所有操作后，编译器会安排释放对象本身占用的内存。对于栈上的对象，这通常由操作系统自动完成；对于堆上的对象，会调用 `delete` 或 `delete[]` 来释放内存。

## 1.25 构造函数的执行步骤

1. 在派生类构造函数中，所有的虚基类及上一层基类的构造函数被调用；
2. 对象的 vptr 被初始化
3. 如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr 被设定之后才做；
4. 执行程序员所提供的代码;

## 1.26 构造函数的扩展过程  

1. 记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；
2. 如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用;
3. 如果 class 有虚表，那么它必须被设定初值，即初始化;
4. 所有上一层的基类构造函数必须被调用;
5. 所有虚基类的构造函数必须被调用

## 1.27 哪些函数不能是虚函数

1. 构造函数，虚函数调用只需要知道“部分的"信息，即只需要知道函数接口，而不需要知道对象的具体类型。但是，我们要创建一个对象的话，是需要知道对象的完整信息的。特别是，需要知道要创建对象的确切类型，因此，构造函数不应该被定义成虚函数；

   而且从目前编译器实现虚函数进行多态的方式来看，虚函数的调用是通过**实例化之后**对象的虚函数表指针来找到虚函数的地址进行调用的，如果说构造函数是虚的，那么虚函数表指针则是不存在的（因为构造函数是虚的，那么同样需要虚函数表来进行调用，但是虚函数表只有在调用构造函数之后才会生成，自相矛盾了），无法找到对应的虚函数表来调用虚函数，那么这个调用实际上也是违反了先实例化后调用的准则。

2. 内联函数，内联函数表示在**编译阶段**进行函数体的替换操作，而虚函数意味着在**运行期间**进行类型确定，所以内联函数不能是虚函数;

3. 静态函数，静态函数不属于对象属于类，**静态成员函数没有this指针**，因此静态函数设置为虚函数没有任何意义。

4. 友元函数，友元函数不属于类的成员函数，不能被继承。**对于没有继承特性的函数没有虚函数的说法**。

## 1.28 萎形继承

一个类可以从多个基类(父类)继承属性和行为。在C++等支持多重继承的语言中，一个派生类可以同时拥有多个基类。

多重继承可能引入一些问题，如萎形继承问题，比如存在同时继承了两个拥有相同基类的类，而最终的派生类又同时继承了这两个类时， 可能导致二义性和代码设计上的复杂性。为了解决这些问题，C++ 提供了**虚继承**，通过在继承声明中使用 `virtual` 关键字，可以避免在派生类中生成多个基类的实例，从而解决了萎形继承带来的二义性。

![image-20250226174129707](/images/$%7Bfiilename%7D/image-20250226174129707.png)

```cpp
// 公共基类
class Base {
public:
    void commonFunction() {
        std::cout << "This is a common function in Base class." << std::endl;
    }
};
// 中间类 1，继承自 Base
class Derived1 : virtual public Base {
};
// 中间类 2，也继承自 Base
class Derived2 : virtual public Base {
};
// 最终派生类，同时继承 Derived1 和 Derived2
class FinalDerived : public Derived1, public Derived2 {
};

FinalDerived obj;
// 如果不用虚继承，该行代码会报错，因为存在二义性，obj会尝试调用commonFunction方法，但不知道调用基类的哪个实现
// 此时需要明确指定调用哪个路径下的函数
// obj.Derived1::commonFunction(); 
// obj.Derived2::commonFunction(); 
obj.commonFunction(); 
```

## 1.29 虚函数和纯虚函数的区别  

**虚函数**：

- 有实现：虚函数有函数声明和实现，即在基类中可以提供默认实现。
- 可选实现： 派生类可以选择是否覆盖虚函数。如果派生类没有提供实现，将使用基类的默认实现。
- 允许实例化： 虚函数的类可以被实例化。即你可以创建一个虚函数的类的对象。
- 调用靠对象类型决定： 在运行时，根据对象的实际类型来决定调用哪个版本的虚函数。
- 用 `virtual`关键字声明： 虚函数使用 `virtual` 关键字声明，但不包含 `=0`。

**纯虚函数**:

- 没有实现：纯虚函数没有函数体，只有函数声明，即没有提供默认的实现。
- 强制覆盖： 派生类必须提供纯虚函数的具体实现，否则它们也会成为抽象类。
- 禁止实例化： **包含纯虚函数的类无法被实例化，只能用于派生其他类**。
- 用`=0`声明：纯虚函数使用`=0`在函数声明末尾进行声明。
- 为接口提供规范： 通过纯虚函数，抽象类提供一种接口规范，要求派生类提供相关实现。

## 1.30 抽象类

**抽象类**是**不能被实例化的类**，它存在的主要目的是为了提供一个接口，供派生类继承和实现。抽象类中可以包含普通的成员函数、数据成员和构造函数，但它必须**至少包含一个纯虚函数**。即在声明中使用 `virtual` 关键字并赋予函数一个 `=0`的纯虚函数。

**派生类必须实现抽象类中的纯虚函数，否则它们也会成为抽象类**  

## 1.31 完美转发（引用折叠+forward）

[C++——完美转发（引用折叠+forward） | 爱吃土豆的个人博客](https://www.aichitudou.cn/2024/11/07/cpp——完美转发（引用折叠-forward）/)

## 1.32 静态成员变量的初始化位置

- **非模板类**的静态成员变量和函数需要在实现文件cpp中初始化，不能在头文件中初始化。因为当该头文件被多个源文件包含时，每个源文件在编译时都会对这个静态成员变量进行定义和初始化，链接时会出现**多重定义错误**。

```cpp
// MyClass.h
class MyClass {
public:
    static int count;
};

// MyClass.cpp
#include "MyClass.h"
int MyClass::count = 0;  // 在 .cpp 中定义和初始化
```

- **模板类**的静态成员变量必须在头文件中定义，模板类中的静态变量可以在头文件中定义，是因为模板类在编译时不会像普通类那样生成具体的类型和符号。相反，模板类的代码只会在模板被实例化时才生成具体的类型。因此，模板类的静态成员变量不会像普通类的静态成员那样在多个编译单元中重复定义。

```cpp
// MyClass.h
class MyClass {
public:
    static int count;
};
int MyClass::count = 0;  // 在 .cpp 中定义和初始化
```

- **`constexpr` 或 `const` 整数类型静态成员变量**：如果是 `const` 整数类型或 `constexpr` 静态常量，它们通常是编译时常量，直接在头文件中初始化，避免多次定义。

```cpp
class MyClass {
public:
    static const int size = 10;
    static constexpr double pi = 3.14159;
};
```

- **inline 静态成员变量（C++17 及以上）**：C++17 引入了 `inline` 关键字，可以在头文件中定义`非 const` 静态成员变量，避免重复定义。

```cpp
// MyClass.h
class MyClass {
public:
    inline static int count = 0;
};
```

**模板的实例化机制**：

- **模板的延迟实例化**：模板本身并不是一个具体的类或函数，它是一种生成类或函数的**蓝图**。编译器在遇到模板定义时，并不会立即生成实际的代码，而是在需要使用模板的具体实例时才进行实例化。例如，当你使用 `MyTemplate<int>` 时，编译器才会根据 `MyTemplate` 模板生成 `int` 类型的具体实例。
- **静态成员变量的实例化**：模板类的静态成员变量同样遵循延迟实例化的规则。**每个不同的模板实例都会有自己独立的静态成员变量副本**（`MyTemplate<int> a` 和`MyTemplate<int> b`共享静态成员，但是`MyTemplate<double> c` 中存在另一个静态成员副本，和`a、c`不共享）。如果将静态成员变量的定义放在 `.cpp` 文件中，编译器可能无法在该文件中获取到**所有**需要的模板实例信息（因为类型有很多，从而导致模板生成的实例也有很多类型，我们只要忽略了其中一种，就有可能导致这种类型的模板实例无法实例化），从而导致某些实例的静态成员变量没有被正确实例化。
- **多重定义问题的特殊性**：对于非模板类的静态成员变量，在多个源文件中重复定义会导致链接错误。但对于模板类的静态成员变量，由于**每个模板实例的静态成员变量是独立的**，不同的模板实例不会导致多重定义问题。只要静态成员变量的定义在每个使用它的翻译单元中都是相同的，就不会出现链接错误。

## 1.33 移动构造函数什么时候会被自动调用

只有当传入的值为右值时，移动构造函数才会被调用。若传入的值是左值，并且类的拷贝构造函数被显式删除（使用 `= delete`），那么编译器会直接报错，而不会调用移动构造函数。若传入的右值，编译器会自动调用移动构造函数。

> 一般来说，`push_back`会根据传入值的类型，选择使用拷贝构造函数或者移动构造函数。而 `std::thread` 存在移动构造函数，如果`push_back`不能使用`thread`的拷贝构造，那为什么不使用移动构造函数呢？

当我们调用**push_back** 时，传递的对象通常是一个**左值**（即命名的变量）。如果直接传递左值，编译器会优先尝试调用拷贝构造函数，如果不存在拷贝构造那么会直接报错，而不会调用移动构造，因为thread内部并不会将左值隐式转换为右值，从而调用移动构造。

总结：

- 如果对象的拷贝构造函数可用，但移动构造函数也存在，`push_back` 会选择合适的构造函数：
- 如果传递的是一个左值，会调用拷贝构造函数。
- 如果传递的是一个右值，会调用移动构造函数。
- 如果对象的拷贝构造函数不可用，但移动构造函数存在，`push_back` 的选择：
  - 如果传递的是一个左值，会直接报错，编译器无法将左值隐式转换为右值从而调用移动。
  - 如果传递的是一个右值，会调用移动构造函数。

```cpp
std::vector<std::thread> threads;
std::thread t1(some_function);

// 尝试通过 push_back 添加
threads.push_back(t1); // 编译错误：std::thread 不支持拷贝
// 尝试通过移动添加
threads.push_back(std::move(t1)); // 这将是合法的，因为 t1 被移动
```

## 1.34 三/五/零法则

三五零法则就是**三法则**、**五法则**、**零法则**。

### a. 三法则

三法则规定，如果一个类需要显式定义以下其中一项时，那么它**必须显式定义**这全部的三项：

- 拷贝构造函数
- 拷贝赋值运算符
- 析构函数

**案例说明**

根据RAII原则，当类手动管理至少一个动态分配的资源时，通常需要实现上述函数。

```cpp
class Student {
public:
    Student(char* name, int id) {
        this->id = id;
        this->name = new char[strlen(name) + 1];
        strcpy(this->name, name);
    }
    
    ~Student() {
        delete[] this->name;
    }

private:
    int id;
    char* name;
};
```

在这个示例中，我们有一个`Student`类手动管理了动态分配的资源（即`name`），构造函数为`name`分配内存，析构函数释放分配的内存。但是当`Student`的对象被复制时会发生什么？

```cpp
Student s1("Tom", 12);
Student s2 = s1;
```

当构造`s2`时，将执行`Student`的默认拷贝构造函数（因为用户没有显式定义拷贝构造函数）。默认的拷贝构造函数将每个成员进行浅拷贝，这意味着`s1.name`和`s2.name`都指向同一块内存。

当`main()`函数结束时会发生什么？`s2`的析构函数将被调用，这将释放`name`所指向的内存，然后`s1`的析构函数被调用，它将再次尝试释放`name`指向的内存，但是这块内存已经被释放了！这就导致重复释放内存。

为了避免这种情况，需要提供适当的复制操作：

```cpp
// 拷贝构造函数
Student(const Student& other) {
    this->id = other.id;
    this->name = new char[strlen(other.name) + 1];
    strcpy(this->name, other.name);
}

// 拷贝赋值运算符
Student& operator=(const Student& rhs) {
    // 防止自拷贝
    if (this != &rhs) {
        this->id = rhs.id;
    
        // delete old data
        if (this->name) {
          delete[] this->name;
        }
    
        this->name = new char[strlen(rhs.name) + 1];
        strcpy(this->name, rhs.name);
    }

    return *this;
}
```

拷贝构造函数和拷贝赋值运算符都执行动态分配资源的**深拷贝**。

### b. 五法则

五法则是三法则的扩展。五法则规定，如果一个类需要显式定义以下其中一项时，**建议**显式定义**全部**的五项：

- 拷贝构造函数
- 拷贝赋值运算符
- 析构函数
- 移动构造函数
- 移动赋值运算符

**因为用户定义（包括=default或=delete）的析构函数、拷贝构造函数或赋值赋值运算符（任意一项），会阻止隐式定义**[**移动构造函数**](https://zh.cppreference.com/w/cpp/language/move_constructor)**和**[**移动赋值运算符**](https://zh.cppreference.com/w/cpp/language/move_assignment)，所以任何**想要移动语义的类必须声明全部五个特殊成员函数**：

> 用户显式定义三法则中的任意一项时（*包括=default或=delete）*，会阻止编译器隐式定义移动语义，导致失去优化的机会。该法则**只是建议**，不做强制要求。

不实现移动语义通常不被视为错误。如果缺少移动语义，编译器通常会尽可能使用效率较低的复制操作。如果一个类不需要移动操作，我们可以轻松跳过这些操作。但是，使用它们会提高效率。

### c. 零法则

如果没有显式定义任何特殊成员函数，则编译器会**隐式定义**所有特殊成员函数（成员变量也会影响隐式定义）。

零法则就是建议优先选择不需要显式定义特殊成员函数的情况。

> 简单来说，如果类需要管理动态资源（如动态内存、文件句柄、网络连接等）就需要遵循五法则；如果类不需要管理动态资源，那最好不要显式定义析构函数、拷贝/移动构造函数、拷贝/移动赋值运算符。如果类的所有成员都遵循零法则，那么整个类也遵循零法则。 零法则说到底就是建议使用**智能指针**和其他资源管理工具，以自动处理资源的创建和销毁。这样大多数类都无需直接管理资源，从而可以避免许多常见的资源管理错误，如资源泄漏、重复释放等。通过遵循零法则，开发者可以编写更简洁、更安全的代码。

当有意将某个基类用于多态用途时，可能需要将它的析构函数声明为public和virtual。由于这会阻止生成隐式移动（并弃用隐式复制），因此如果希望保持移动和复制操作的支持，可以显式定义这些操作，或使用 **= default** 来告诉编译器生成默认的实现。

```
class base_of_five_defaults
{
public:
    base_of_five_defaults(const base_of_five_defaults&) = default;
    base_of_five_defaults(base_of_five_defaults&&) = default;
    base_of_five_defaults& operator=(const base_of_five_defaults&) = default;
    base_of_five_defaults& operator=(base_of_five_defaults&&) = default;
    virtual ~base_of_five_defaults() = default;
};
```

但是，过多的定义拷贝、移动构造函数/运算符，如果不小心进行对象复制，可能会导致**切片现象**。*切片发生在将派生类对象赋值给基类对象时，导致只保留基类部分，丢失派生类特有的属性和行为*。这是因为基类对象不能持有派生类的信息。

这也是为什么多态类经常把**复制定义（不是移动）**=delete的原因：

- **避免切片**：通过将拷贝构造函数和拷贝赋值运算符显式定义为 = delete，可以防止基类对象无意中复制派生类对象，从而避免切片现象。
- **控制对象的生命周期**：如果类只应该通过指针或引用来管理，而不是通过值来复制，将复制操作禁用可以更好地控制对象的使用。

比如：

```
class Base {
public:
    virtual ~Base() = default;
    // 禁用拷贝构造和拷贝赋值以避免切片
    Base(const Base&) = delete;
    Base& operator=(const Base&) = delete;

    // 可以定义移动构造和移动赋值
    Base(Base&&) = default;
    Base& operator=(Base&&) = default;
};

class Derived : public Base {
public:
    ~Derived() override = default;
    // 其他成员...
};
```

我们可以保留析构、移动构造、移动赋值运算符，将复制构造、复制运算符给delete，避免切片现象。

## 1.34  std::ref和std::move的区别

**a. std::ref**

- **功能**：`std::ref` 用于创建一个可拷贝的引用**包装器**，将给定对象（**左值引用，不接受右值引用**）作为引用传递给其他需要按值传递的函数，如线程函数。它主要用于在传递引用时避免意外拷，保持对象的原始引用，**不会转移所有权**。
- **使用场景**：在需要将引用传递给 STL 算法、线程或其他需要值拷贝的函数时使用。

thread中便用到了此原理，thread传入的参数若不经过std::ref包装，均会作为右值被保存使用，可以参考文章：

[并发编程（1）——线程、thread源码解析 | 爱吃土豆的个人博客](https://www.aichitudou.cn/2024/11/03/并发编程（1）——线程、thread源码解析/#3-5-总结)

> std::ref只是尝试模拟引用传递，并不能真正变成引用，在非模板情况下，std::ref根本没法实现引用传递，只有模板自动推导类型或类型隐式转换时，ref能用包装类型reference_wrapper来代替原本会被识别的值类型，而reference_wrapper能隐式转换为被引用的值的引用类型。 为什么std::ref可以保存参数的引用呢？实现在thread修改参数值，影响到外部传入参数值的效果？

```cpp
template <class _Ty>
_NODISCARD _CONSTEXPR20 reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}
```

`reference_wrapper`是一个类类型，说白了就是**将参数的地址和类型保存起来**。

```cpp
_CONSTEXPR20 reference_wrapper(_Uty&& _Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(_STD declval<_Uty>()))) {
    _Ty& _Ref = static_cast<_Uty&&>(_Val);
     _Ptr      = _STD addressof(_Ref);
}
```

当我们要使用这个类对象时，自动转化为**取内部参数的地址里的数据**即可，就达到了和实参关联的效果

```cpp
_CONSTEXPR20 operator _Ty&() const noexcept {
    return *_Ptr;
}
_NODISCARD _CONSTEXPR20 _Ty& get() const noexcept {
    return *_Ptr;
}
```

我们可以这样理解通过 `std::ref` 传递给 `std::thread` 构造函数的参数：`std::ref` 传入的参数会被包装成 `std::reference_wrapper` 对象，该对象在`std::thread` 会被改造成右值引用，例如 `std::ref(int)` 实际是作为 `std::reference_wrapper<int>` 对象保存在 `std::thread` 的类成员里。当线程执行时，会触发 `std::reference_wrapper` 的 `operator()`（仿函数调用），进而通过这个包装对象获取到外部实参所在地址中的数据，从而实现对外部实参的引用传递。

**b. std::move** 

- **功能**：`std::move` 用于将对象的所有权转移，表示该对象可以被“移动”。它不会执行任何实际的移动操作，而是将对象转换为**右值引用**，使得可以**调用移动构造函数或移动赋值运算符**。可以接受左值或右值，对左值使用时将其转换为右值引用，对右值使用仍保持为右值引用

> **std::ref 关注的是引用的传递，而 std::move 则关注对象的所有权转移**

**std::move** **的行为**：

- `std::move` 并不执行实际的“移动操作”，而是将对象转化为一个“右值引用”（T&&），提示编译器可以安全地“移动”数据。
- 真正的数据移动发生在随后调用的移动构造函数或移动赋值运算符中。
- 一旦使用 `std::move`，原数据的状态可能会变成“未定义的有效状态”（例如清空容器、将指针置为 `nullptr` 等），这会破坏原队列中的数据。

## 1.35 类型成员和非类型成员

> 在定义类型别名的时候需要注意，如果定义别名的类型是已知类型，直接加 `typedef` 即可，但对于模板类中嵌套的类型，我们需要额外加 `typename` 明确是类型。

```cpp
//存储元素的类型为pair，由key和value构成
typedef std::pair<Key, Value> bucket_value;
//由链表存储元素构
typedef std::list<bucket_value> bucket_data;
//链表的迭代器
typedef typename bucket_data::iterator bucket_iterator;
```

比如上面 `std::pair` 和 `std::list` 是标准库中的普通模板类，它们本身是**已知类型**，不需要额外的提示来区分；而`bucket_data::iterator` 是一个嵌套类型，定义在 `bucket_data`（即 `std::list<bucket_value>`）内部，我们需要加 `typename` 表明它是一个类型，而不是其他可能的非类型成员（数据成员、成员函数、静态成员变量、枚举值）

注意区分类型成员和非类型成员：

- **类型成员**是类中定义的类型，主要包括：typedef 或 using 定义的**类型**别名、嵌套类、模板嵌套类型
- **非类型成员**是类的对象或行为，而不是类型定义，主要包括：数据成员（成员变量）、成员函数、静态成员变量、枚举值

```cpp
class Example {
public:
    typedef int TypeAlias;     // 类型成员（typedef 定义的别名），TypeAlias 作为 int 的别名
    using AnotherAlias = double; // 类型成员（using 定义的别名），AnotherAlias 作为 double 的别名
    class NestedClass {};      // 类型成员（嵌套类）
    struct NestedStruct { };   // 类型成员（嵌套结构体）
    template <typename T>
    struct NestedTemplate {};  // 类型成员（嵌套模板）
    
    int data_member;          // 非类型成员（数据成员）
    static double static_var; // 非类型成员（静态变量）
    void member_function();   // 非类型成员（成员函数）
    enum { Constant = 42 };   // 非类型成员（枚举值）
};
```

> **为什么需要这样区分？**

在模板中，C++ 编译器无法直接区分某个嵌套标识符是 **非类型成员** 还是 **类型成员**，因为模板参数可能影响其定义。例如：

```cpp
template <typename T>
void func() {
    typename T::NestedType a; // 使用 typename，明确 NestedType 是一个类型，用该类型声明一个变量 a
    T::static_member = 5;     // 访问非类型成员，无需 typename
}
```

如果不加 `typename`，编译器可能认为 `T::NestedType` 是一个变量或其他非类型成员，而报错。但 `T::static_member` 是一个非类型成员（静态变量），因此不需要 `typename`。

当我们对作用域或类重命名时，需要遵循以下规则：

```cpp
// 因为beast、http、net是作用域，所以可以直接用namespace重命名
// 但是tcp是一个类，所以只能通过using重命名
namespace beast = boost::beast;
namespace http = beast::http;
namespace net = boost::asio;
using tcp = boost::asio::ip::tcp;
```

## 1.36 左值和右值

- **左值**：可以被取地址，可以被修改（**除了const修饰的左值**），例如变量名或解引用的指针。
  - 可以出现在赋值号 = 的**左边或右边**的表达式，它有一个明确的内存地址，可以被引用或修改。
  - 可以绑定到左值引用（`T&`）的对象，通常有名字并且可以访问其内存地址。
- **右值**：不能被取地址，也不能被修改，例如字面**常量**、表达式的**返回值**、函数的（非左值引用）**返回值**。只能出现在赋值号 = 的右边的表达式，它没有一个明确的内存地址，不能被引用或修改
  - 不能直接绑定到左值引用上，但可以绑定到右值引用（`T&&`）上

> 但注意，**有名字的右值引用变量会被视为左值**。

当一个右值引用（如 `int&& a`）有了名字后，它就成为了一个可以访问的对象，可以通过它来取地址或者修改它的值，因此它满足左值的特征。虽然它最初是绑定到右值的，但它现在作为一个有名字的对象（有名字的变量包括右值引用变量，都是有明确内存地址的），就变成了左值。

```cpp
// 接受左值引用的函数
void processValue(int& value) {
    std::cout << "Processing lvalue: " << value << std::endl;
}
// 接受右值引用的函数
void processValue(int&& value) {
    std::cout << "Processing rvalue: " << value << std::endl;
}

int main() {
    int&& rref = 10; // rref 是一个右值引用，绑定到右值 10
    // 调用 processValue 函数，由于 rref 是有名字的右值引用变量，会被视为左值
    processValue(rref); 
    // 如果要将 rref 作为右值传递，需要使用 std::move
    processValue(std::move(rref)); 
    return 0;
}
```

- `int&& rref = 10;` 这里 `rref` 是一个右值引用，它绑定到了右值 `10`。
- **将右值引用变量视为左值**：`processValue(rref);` 调用 `processValue` 函数时，因为 `rref` 有名字，编译器会把它当作左值，所以会调用接受左值引用的 `processValue` 函数。
- **使用 `std::move` 将其转换为右值**：`processValue(std::move(rref));` 通过 `std::move` 把 `rref` 强制转换为右值，这样就会调用接受右值引用的 `processValue` 函数。

## 1.37 临终值和纯右值

临终值（xvalue）和纯右值（prvalue）都属于右值。

- 纯右值是传统意义上的右值，它是一个不代表任何对象的表达式，通常是字面量、临时对象或者求值结果不与任何对象关联的表达式。纯右值没有标识符，没有持久的内存地址，其生命周期仅限于表达式求值期间。例如：字面量 `10`、`3.14`，函数返回的非引用类型结果（如 `int func() { return 5; }` 中的 `func()` 返回值），以及算术表达式 `2 + 3` 等都是纯右值。
- 临终值代表一个对象，该对象的资源（如动态分配的内存）可以被安全地移动，因为这个对象即将结束其生命周期。**临终值有一个明确的对象与之关联，但它的资源即将被转移**。例如：使用 `std::move` 转换后的对象（`std::move(obj)`）、返回右值引用的函数调用结果（`int&& func() { ... }` 中的 `func()` 返回值）都是临终值。

# 2. C++内存管理

## 2.1 C++内存分配

C++程序运⾏时，内存被分为几个不同的区域，每个区域负责不同的任务。

![image-20250225220954179](/images/$%7Bfiilename%7D/image-20250225220954179.png)

- 栈：
  - 由编译器管理分配和回收，存放局部变量、形参和返回值。函数的调⽤和返回通过栈来管理 。
  - “向下增长” 意味着随着程序中函数调用、局部变量声明等操作，栈区占用的内存空间会朝着内存低地址方向扩展。例如，当一个函数被调用时，其形参和局部变量会依次压入栈中，栈顶指针向低地址移动 。
- 堆：
  - 由程序员管理，需要⼿动 `new` 和`delete` 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎片的情况。
  - “向上增长” 表示随着程序员不断调用内存分配函数来获取更多内存，堆区占用的内存空间会朝着内存高地址方向扩展。
- 全局/静态存储区：
  - 分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。
  - ⽣命周期是整个程序运⾏期间。在程序启动时分配，程序结束时释放  
  - 内存在**程序编译**的时候就已经分配好  
- 常量存储区：存储常量，⼀般不允许修改。
- 代码区：存放程序的⼆进制代码。

## 2.2 堆和栈的区别

堆：

- 由程序员**手动管理**，需通过new delete进行分配和回收，不进行回收会造成内存泄漏。
- **不连续的空间**。系统中有一个空闲链表，当有程序申请的时候，系统遍历空闲链表找到**第一个**大于等于申请大小的空间分配给程序，但频繁的分配和释放内存，可能会导致**内存碎片**的产生（比如，一开始分配了几个小块内存，后来又释放了其中几块内存，这样就会在已分配的内存之间形成一些小块的空闲空间，这些空闲空间由于不连续，可能无法满足后续较大内存块的分配需求，就像市场中一些摊位被拆除后，剩下的一些小空间无法再容纳大型的摊位一样）
- 从低地址向高地址扩展，**访问速度慢**（堆上的内存分配和释放是动态的，系统需要花费一些时间来管理这些内存，比如在分配内存时需要查找合适的空闲空间，在释放内存时需要进行一些清理和标记操作）

栈：

- 由**编译器进行管理**，在需要时由编译器自动分配空间，在不需要时候自动回收空间，一般保存的是局部变量和函数参数等

- **连续的内存空间**。在函数调用的时候，首先入栈的主函数的下一条可执行指令的地址，然后是函数的各个参数。

  大多数编译器中，参数是从右向左入栈(原因在于采用这种顺序，是为了让程序员在使用C/C++的“函数参数长度可变”这个特性时更方便。以`printf`这类可变参数函数为例，它需要提前知晓可变参数表中各变量的类型，而第一个参数的作用正是描述这些类型。若从左向右压栈，这个关键参数就会被置于栈底。由于可变参数函数执行的首要步骤是解析可变参数表中各参数的类型，这就意味着一开始就得获取位于栈底的该参数。但栈遵循后进先出原则，栈底元素是最早入栈且最后才能被访问的，想要从栈底获取参数会涉及复杂的栈操作，效率低下且容易出错。所以从右向左压栈，把描述可变参数类型的关键参数放在栈顶附近，函数解析时能更便捷快速地获取，极大简化了可变参数函数的实现与使用 。

  本次函数调用结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运行，不会产生碎片。

- 访问速度很快，因为栈上的内存分配是连续的，并且系统对栈的管理非常高效，不需要像堆那样进行复杂的查找和管理操作

## 2.3 计算下列类的大小

```
class A {}; // sizeof(A) = 1
```

对于空类，`sizeof(A)` 的结果为 1 字节。这是因为在 C++ 里，每个对象都必须有独一无二的内存地址，即便类中没有任何成员变量，编译器也会为其分配至少 1 字节的内存空间，以此保证该类的不同对象能够有不同的地址。

```cpp
class A{virtual Fun(){} }; // 4或8
```

存在虚函数时，编译器会为这个类创建一个虚函数表（vtable），用于存储该类的所有虚函数的地址。同时，**类的每个对象都会包含一个指向虚函数表的指针**（vptr）。

- 在 32 位系统中，指针的大小是 4 字节，所以 `sizeof(A)` 为 4 字节。
- 在 64 位系统中，指针的大小是 8 字节，`sizeof(A)` 则为 8 字节。

```cpp
class A{static int a; }; // 1
```

静态成员变量属于类本身，而不是类的某个具体对象，它被存储在全局数据区，不占用对象的内存空间。所以，就像空类一样，编译器为对象分配 1 字节的内存，确保其有唯一的地址。

```cpp
class A{int a; }; // 4
```

在这个类中，只有一个 `int` 类型的成员变量 `a`。在大多数系统中，`int` 类型通常占用 4 字节的内存空间，因此 `sizeof(A)` 等于 4 字节。

## 2.4 内存对齐

> **内存对齐**是指将数据存储在特定的内存地址上，使得数据的起始地址是其大小的整数倍（为了方便计算机去读写数据）。

**作用：**

经过内存对齐之后，CPU 的内存访问速度大大提升。因为 CPU 把内存当成是一块一块的，块的大小可以是2，4，8，16 个字节，因此 CPU 在读取内存的时候是一块一块进行读取的，块的大小称为内存读取粒度。比如说 CPU 要读取一个4个字节的数据到寄存器中(假设内存读取粒度是 4)，如果数据是从0字节开始的，那么直接将 0-3 四个字节完全读取到寄存器中进行处理即可

如果数据是从1字节开始的，就首先要将前4个字节读取到寄存器，并再次读取 4-7 个字节数据进入寄存器，接着把0字节，5，6，7字节的数据剔除，最后合并1，2，3，4字节的数据进入寄存器，所以说，当内存没有对齐时，寄存器进行了很多额外的操作，大大降低了CPU的性能。

另外，还有一个就是，有的CPU 遇到未进行内存对齐的处理直接拒绝处理，不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。所以内存对齐还有利于平台移植。

**原理：**

对齐的地址一般都是 n（n = 2、4、8）的倍数。

1. 1 个字节的变量，例如 char 类型的变量，放在任意地址的位置上； 
2. 2 个字节的变量，例如 short 类型的变量，放在 2 的整数倍的地址上； 
3. 4 个字节的变量，例如 float、int 类型的变量，放在 4 的整数倍地址上； 
4. 8 个字节的变量，例如 long long、double 类型的变量，放在 8 的整数倍地址上；

**结论：**

- 结构体尾部补齐规则：

  结构体整体的内存占用需要根据其中最大类型的成员来进行调整。如果结构体中最大类型是像 `int` 这种占 4 个字节的类型，并且结构体的结尾地址不是 4 的倍数，那么需要将结构体的内存空间补齐到离当前结尾地址最近的 4 的倍数地址；若最大类型是像 `double` 这种占 8 个字节的类型，且结构体结尾地址不满足 8 的倍数，就需要补齐到离最近的 8 的倍数地址，依此类推。

- 结构体嵌套情况：

  当结构体中包含子结构体时，子结构体成员变量的起始地址由子结构体中最大类型的变量决定。例如，若结构体 `a` 包含结构体 `b`，而结构体 `b` 中包含 `char`、`int`、`double` 等元素，那么结构体 `b` 应该从 8 的整数倍地址开始存储。具体可参考相关示例。

- 含数组成员的结构体：

  如果结构体中包含数组成员，例如 `char a[5]`，其对齐方式等同于连续写 5 个 `char` 类型的变量，即按一个字节进行对齐。你可以在多个示例中观察到这种对齐方式。

- 含联合体成员的结构体：

  若结构体中包含联合体（`union`）成员，联合体的起始地址需要取联合体中最大类型的整数倍地址。相关示例可以帮助你更好地理解这一规则。

**举例：**

```cpp
struct stu1 {
    char a[18];
    double b;
    char c;
    int d;
    short e;
```

- `char` 类型的大小为 1 字节，它的对齐值也是 1 字节，所以 `a` 可以从任意地址开始存储，假设其起始地址为 0，则 a[18] 结束的地址为 17；
- `double` 类型的大小为 8 字节，对齐值为 8 字节，由于 `a` 只占 18 字节，若 `b` 紧接着 `c` 存储，其起始地址为 18，不满足 8 字节对齐要求。因此，编译器会在 `a` 后面插入 6个填充字节，使 `i` 从地址 24 开始存储，占用 8 个字节（地址 24 - 31）;
- 然后存储 c，地址为 32；
- `int` 类型大小为 4 字节，对齐值为 4 字节，所以会在 c 后补 3 字节，使得 d 从 36 开始存储，36~39；
- `short` 类型的大小为 2 字节，对齐值为 2 字节。`d` 结束地址是 39，为了满足 `e` 的对齐要求，`e` 从地址 40 开始存储，占用 2 字节，地址范围是 40 - 41。
- 结构体的对齐值取决于其成员中最大的对齐值，在 `struct stu1` 中，最大对齐值是 `double` 类型的 8 字节。当前结构体成员总共占用了 42 字节（18 + 7 + 1 + 3 + 4 + 1 + 2），但为了满足 8 字节对齐，需要在结构体末尾再插入 6 个填充字节，使得结构体总大小为 48 字节。

## 2.5 智能指针

[C++——智能指针剖析 | 爱吃土豆的个人博客](https://www.aichitudou.cn/2024/11/19/cpp——智能指针源码剖析/)

## 2.6 野指针和悬浮指针

- 野指针是指指向一个随机的、无效的或者未分配内存地址的指针。这种指针**没有被正确初始化**，它可能指向任何地方，访问野指针可能会导致程序崩溃、产生不可预期的结果或者引发安全漏洞。
  - 产生原因：内存释放后未置空、未初始化（声明指针后没有对其进行初始化赋值，指针的值是随机的）
- 悬浮指针通常是指指针原本指向一个合法的内存地址，但由于该内存被释放或者对象的生命周期结束，导致指针指向的内存不再有效，但指针本身仍然保留着原来的地址值。
  - 产生原因：对象生命周期结束（在函数内部定义的对象，当函数执行结束后，对象会被销毁，指向该对象的指针就会变成悬浮指针）
  - 解决方法：避免在函数中返回局部变量的引用。使用返回指针或智能指针而不是引用，如果需要在函数之外使用函数内部创建的对象。

## 2.7 内存模型

[并发编程（10）——内存模型、原子操作以及单例模式的三种实现 | 爱吃土豆的个人博客](https://www.aichitudou.cn/2024/11/12/并发编程（10）——内存模型、原子操作以及单例模式的三种实现/)

[并发编程（11）——同步、先行关系 | 爱吃土豆的个人博客](https://www.aichitudou.cn/2024/11/20/并发编程（11）——同步、先行关系/)

[并发编程（12）——内存次序与内存模型,以及单例模式的三种实现 | 爱吃土豆的个人博客](https://www.aichitudou.cn/2024/11/21/并发编程（12）——内存次序与内存模型序,以及单例模式的三种实现/)

[并发编程（14）——内存栅栏 | 爱吃土豆的个人博客](https://www.aichitudou.cn/2024/11/28/并发编程（14）——内存栅栏/)

## 2.8 类如何实现只能静态分配和只能动态分配  

在 C++ 里，“类只能静态分配” 意味着该类的对象**只能**在栈上创建，不能通过 `new` 运算符在堆上动态分配；“类只能动态分配” 则表示该类的对象**只能**通过 `new` 运算符在堆上创建，不能在栈上静态分配。

要让类**只能静态分配**，也就是禁止在堆上动态分配对象，可通过将类的 `new` 和 `delete` 运算符重载为私有成员来达成。因为当 `new` 和 `delete` 是私有成员时，外部代码无法调用它们来进行堆上的对象分配和释放操作。

```cpp
class StaticAllocationOnly {
private:
    // 将 new 和 delete 运算符重载为私有成员
    static void* operator new(size_t size);
    static void operator delete(void* ptr);
public:
    StaticAllocationOnly() {}
    ~StaticAllocationOnly() {}
};
// 可以在栈上静态分配对象
StaticAllocationOnly obj;
// 但不能使用 new 进行动态分配，会报错
StaticAllocationOnly* ptr = new StaticAllocationOnly();
```

要使类**只能动态分配**，也就是禁止在栈上静态分配对象，可**将类的析构函数设为私有成员**。由于栈上的对象在其作用域结束时会自动调用析构函数，而私有析构函数外部无法直接调用，所以不能在栈上创建对象。

但注意，析构函数私有之后，我们需要重新定义一个公有的静态成员函数来负责对象的销毁。

# 3. C++新特性

## 3.1 once_flag和call_once

`std::call_once` 和 `std::once_flag` 是 C++11 中引入的线程安全的函数和类型，用于**确保某个函数只被调用一次。**

- `std::once_flag` 是一个**类型**，用于标记一段代码是否已经被执行过。它必须通过**引用传递**给 `std::call_once` 函数，以确保在多线程环境下仅仅执行一次。
- `std::call_once` **函数**接受两个参数：**一个可调用对象**（可以是函数、[lambda 表达式](https://zhida.zhihu.com/search?content_id=248801636&content_type=Article&match_order=1&q=lambda+表达式&zhida_source=entity)等）和一个 `std::once_flag` 对象的引用。该函数会检查 `std::once_flag` 对象是否被设置过，如果没有，就调用可调用对象，并设置 `std::once_flag` 对象为已设置状态。`std::call_once` 函数充当了加锁的作用，但不用手动操作，函数会自动进行加解锁。

使用 `std::call_once` 和 `std::once_flag` 可以避免在多线程环境下多次执行同一个函数，从而提高程序性能和正确性。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
std::once_flag flag;
void do_something()
{
    //call_once中的 lambda 表达式只执行一次
    std::call_once(flag, []() {
        std::cout << "do_something() called once" << std::endl;
    });
    std::cout << "Thread id" << std::this_thread::get_id() << std::endl;
}
int main()
{
    std::thread t1(do_something);
    std::thread t2(do_something);
    t1.join();
    t2.join();
    return 0;
}
```

在这个例子中，我们定义了一个名为 `do_something` 的函数，并将其作为参数传递给 `std::call_once` 函数。 `std::once_flag` 对象被声明为全局变量，以便在多个线程之间共享。

- 当第一次调用 `do_something` 函数时，`std::call_once` 将检查 `std::once_flag` 是否已经被设置过。由于初始状态为未设置，因此 `std::call_once` 将执行提供的可调用对象——这里是一个 lambda 表达式，输出一条消息表示函数被调用了一次。
- 当第二次调用 `do_something` 函数时，`std::call_once` 将不再执行提供的可调用对象，因为 `std::once_flag` 已经被设置过。

通过这种方式，我们可以确保 `do_something` 函数中`std::call_once` 提供的可调用对象被调用一次，无论有多少个线程同时调用它。

```cpp
do_something() called once
Thread id139891421738688
Thread id139891413345984
```

单例模式有三种实现方式，通过`std::call_once`和`std::once_flag`实现便是其中的一种。

## 3.2 lambda

`Lambda`表达式可以表示**闭包**，因为C++不像go一样存在闭包操作，但可以通过`lambda`操作实现**伪闭包**。

**闭包就是能够读取其他函数内部变量的函数**。例如在 javascript 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。这句话里面重点，**闭包是一个函数内部的函数，可以读取它所关联函数的局部变量。**

**1）原型**

```cpp
[capture list] (params list) mutable exception-> return type { function body }
```

- capture list：捕获外部变量列表
- params list：形参列表
- mutable指示符：用来说用是否可以修改捕获的变量
- exception：异常设定
- return type：返回类型
- function body：函数体

通常使用以下三种方式省略某写成分来声明不完整的lamba表达式：

```cpp
// 格式1
[capture list] (params list) -> return type {function body}
// 格式2
[capture list] (params list) {function body}
// 格式3
[capture list] {function body}
```

其中：

- 格式 1 显式指定返回类型
- 格式 2 省略了返回值类型，但编译器可以根据以下规则推断出 Lambda 表达式的返回类型：
  - 如果 function body 是**完全由一条返回语句**组成时（**只有return 语句）**，则该 Lambda 表达式的返回类型由return语句的返回类型确定；
  - 如果 function body 中没有 return 语句，则返回值为 void 类型。
- 格式 3 中省略了参数列表，类似普通函数中的无参函数。

```cpp
auto singleExpressionLambda = [](int x) { return x * 2; }; // 返回类型可以自动推断

auto multiStatementLambda = [](int x) -> int { // 必须显式指定返回类型为 int
    if (x > 0) return x;
    else return -x;
};
```

**2）如何使用**

```cpp
   // 1  匿名调用
   [](string name)
   {
       cout << "this is anonymous" << endl;
       cout << "hello " << name << endl;
   }("zack");
```

上述代码定义了一个匿名函数后直接调用。我们可以通过auto初始化一个变量存储lambda表达式

```cpp
// 2 通过auto赋值
   auto fname = [](string name)
   {
       cout << "this is auto  " << endl;
       cout << "hello " << name << endl;
   };

   fname("Rolin");
```

通过auto定义fname，然后存储了lambda表达式，之后调用fname即可。也可以通过函数指针的方式接受lambda表达式

```cpp
typedef void (*P_NameFunc)(string name);
// 3 函数指针
P_NameFunc fname2 = [](string name)
{
    cout << "this is P_NameFunc " << endl;
    cout << "hello " << name << endl;
};

fname2("Vivo");
```

定义了一个类型别名 P_NameFunc，它代表一个函数指针，P_NameFunc定义了fname2函数指针接受了lambda表达式。也可以通过function对象接受lambda表达式

```cpp
// 4 function
    std::function<void(string)> funcName;
    funcName = [](string name)
    {
        cout << "this is function " << endl;
        cout << "hello " << name << endl;
    };

    funcName("Uncle Wang");
```

**3)lamba的捕获**

Lambda 表达式可以使用其作用域内的任何动态变量，但必须明确声明（明确声明哪些外部变量可以被该 Lambda 表达式使用）。那么，在哪里指定这些外部变量呢？Lambda 表达式通过在最前面的方括号 [] 来明确指明其内部可以访问的外部变量，这一过程也称过 Lambda 表达式“捕获”了外部变量。

类似参数传递方式（值传递、引入传递、指针传递），在 Lambda 表达式中，外部变量的捕获方式也有**值捕获、引用捕获、隐式捕获。**

**1.值捕获**

```cpp
// 1.值捕获
int age = 33;
string name = "zack";
int score = 100;
string job = "softengineer";
//值捕获
[age, name](string name_)
{
    cout << "age is " << age << " name is " << name << " self-name is " << name_ << endl;
}("Novia");
```

上述lambda表达式捕获了age和name，是以值的方式来捕获的。所以**无法在lambda表达式内部修改age和name的值**，如果修改age和name，编译器会报错，提示无法修改const常量，**因为age和name是以值的方式被捕获的。**

**2.引用捕获**

```cpp
int age = 33;
string name = "zack";
int score = 100;
string job = "softengineer";
[&age, &name](string name_)
{
    cout << "age is " << age << " name is " << name << " self-name is " << name_ << endl;
    name = "Xiao Li";
    age = 18;
}("Novia");
```

[]里age和name前边添加了&，此时age和name是以**引用方式捕获**的。所以**可以在lambda表达式中修改age和name的值**。

C++的lambda表达式虽然可以捕获局部变量的引用，达到类似闭包的效果，但不是真的闭包，golang和python等语言通过闭包捕获局部变量后可以增加局部变量的声明周期，C++无法做到这一点，所以下面的调用会出现崩溃（C++可以通过智能指针实现伪闭包）。

```cpp
vector<function<void(string)>> vec_Funcs;
void use_lambda2()
{
    int age = 33;
    string name = "zack";
    int score = 100;
    string job = "softengineer";

    vec_Funcs.push_back([age, name](string name_)
                        {   cout << "this is value catch " << endl;
                            cout << "age is " << age << " name is " << name << " self-name is " << name_ << endl; });
    //危险，不要捕获局部变量的引用
    vec_Funcs.push_back([&age, &name](string name_)
                        {   cout << "this is referenc catch" << endl;
                            cout << "age is " << age << " name is " << name << " self-name is " << name_ << endl; });
}

void use_lambda3()
{
    for (auto f : vec_Funcs)
    {
        f("zack");
    }
}

int main(){
    use_lambda2();
    use_lambda3();
}
```

use_lambda2中将lambda表达式存储在function类型的vector里，当use_lambda2结束后，里边的局部变量都被释放了，而vector中的lambda表达式还存储着局部变量的引用，在调用use_lambda3时调用lambda表达式，此时访问局部变量已经被释放了，所以导致程序崩溃。

但如果将传入的参数通过智能指针指向，并将智能指针作为形参传入函数，那么智能指针内部的引用计数会自动加减，防止局部变量被提前释放导致程序崩溃（可以参考C++服务器中的伪闭包操作）

**3. 全部用值捕获，name用引用捕获**

```cpp
int age = 33;
string name = "zack";
int score = 100;
string job = "softengineer";
[=, &name]()
{
    cout << "age is " << age << " name is " << name << " score is " << score << " job is " << job << endl;
    name = "Cui Hua";
}();
```

通过=表示所有变量都以值的方式捕获，如果希望某个变量以引用方式捕获则单独在这个变量前加&

4. 全部用引用捕获，只有name用值捕获

```cpp
int age = 33;
string name = "zack";
int score = 100;
string job = "softengineer";
[&, name]()
{
     cout << "age is " << age << " name is " << name << " score is " << score << " job is " << job << endl;
}();
```

通过&方式表示所有变量都已引用方式捕获，如果希望某个变量以值方式捕获则单独在这个变量前加=。

总结：

- [] 不捕获任何外部变量
- [变量名, …] 默认以值的形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用 & 说明符）
- [=] 值捕获，捕获所有外部变量，在函数内有个副本使用
- [&] 引用捕获，捕获所有外部变量，在函数体内当作引用使用
- [=, &x] 值捕获所有外部变量，只按引用捕获 x 变量
- [&, =x] 引用捕获所有外部变量，只按值捕获 x 变量
- [this] 捕获当前类中的 this 指针。如果已经使用了 & 或者 = ，无需显式写出 `[this]`，编译器会自动捕获 `this` 指针，方便在 Lambda 函数体中访问类的成员

## 3.3 std::function

`std::function`是从c++11开始支持的特性，使用它需要包含`<functional>`头文件

在cppreference中解释为：类模板 **std::function** 是一个通用的多态函数包装器。`std::function`的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括

- 函数
- 函数指针
- lambda 表达式
- bind 创建的对象
- 重载了函数调用运算符的类（仿函数）

`std::function`可以绑定全局函数，静态函数，但是绑定类的成员函数时，必须要借助[`std::bind`](https://zhida.zhihu.com/search?content_id=248801636&content_type=Article&match_order=1&q=std%3A%3Abind&zhida_source=entity)的帮忙

它不能被用来检查相等或者不相等，但是可以与 NULL 或者 nullptr 进行比较

**通俗的来说可以把它当做一个函数指针来使用**

**1）如何使用**

function的模板是 **std::function<返回值类型(传入参数类型)> 方法名**

```cpp
typedef std::function<void(std::shared_ptr<CSession>, const short& msg_id, const std::string& msg_data)> FunCallBack;
```

这里我定义了一个名为 `FunCallBack` 的函数指针，它传入的参数类型： 1）`std::shared_ptr<CSession>` 实现伪闭包，防止目标被提前释放；2）`constshort& msg_id`，用于存储消息id；3）`const std::string& msg_data` 用于存储消息内容；返回类型为void。

```cpp
std::map<short, FunCallBack> _fun_callback;

void LogicSystem::RegisterCallBacks() {
	_fun_callback[MSG_HELLO_WORD] = std::bind(&LogicSystem::HelloWordCallBack,
		this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);
}

void LogicSystem::HelloWordCallBack(std::shared_ptr<CSession> session, const short& msg_id, const std::string& msg_data);
```

其中，HelloWordCallBack是`_fun_callback`类型的函数指针，被bind绑定于`_fun_callback[MSG_HELLO_WORD]`中，对应的键`MSG_HELLO_WORD`会触发对应的值`HelloWordCallBack`。

## 3.4 std::bind

`std::bind`将原函数的几个参数通过bind绑定传值，返回一个新的可调用对象，也就是改造现有函数，生成新的函数。

比如我现在需求，我要一个有 2 个 int 类型参数的函数，并且第二个参数默认为 2。你可千万不要屁颠屁颠的在去写一个`f(int i, int i = 2)`，这里`std::bind`的作用体现出来了，看：

```cpp
int f(int a, int b);
std::bind(&f, std::placeholders::_1, 2);
```

然后将bind的返回值交给function，定义函数原型fun如下

```cpp
std::function<int(int,int)> fun = std::bind(&f, std::placeholders::_1, 2);
```

> **注：1）std::bind返回后的函数和原函数是完全不同的函数，他们的内存地址完全不同**
> **2）bind中的‘&’都是取址符不是引用**

在使用 `std::bind` 绑定可调用对象时，有时加 `&` 有时不加，这主要取决于可调用对象的类型：

- 对于普通函数，加 `&` 和不加 `&` 效果是一样的。因为函数名在大多数情况下会隐式转换为函数指针。
- 对于成员函数，必须加 `&`。因为成员函数指针和普通函数指针不同，它需要明确指出是成员函数的指针，不能通过隐式转换得到。
- 对于仿函数，通常不加 `&`。仿函数是一个重载了 `()` 运算符的类的对象，它本身就是一个可调用对象，不需要取地址。

**1）如何使用**

`std::bind`函数定义在头文件`<functional>`中，`std::bind` 可以将可调用对象和参数一起绑定，绑定后的结果使用`std::function`进行保存，并延迟调用到任何我们需要的时候，所以经常用来实现**回调函数**。

`std::bind`的作用：

- 将可调用对象与参数一起绑定为另一个 `std::function` 供调用
- 将 n 元可调用对象转成 m(m < n) 元可调用对象，绑定一部分参数，这里需要使用`std::placeholders`

**2）原型**

```cpp
template <class Fn, class... Args>
/* unspecified */ bind (Fn&& fn, Args&&... args);

template <class Ret, class Fn, class... Args>
/* unspecified */ bind (Fn&& fn, Args&&... args);
```

模板1：

- 基于参数`fn`返回一个函数对象，并且以`args`参数绑定为函数对象的参数。
- 每个参数要么绑定一个参数值，要么绑定为一个`std::placeholders`（占位符，如 _1, _2, ..., _n）。
- 如果参数绑定成一个值，那么返回的函数对象将总使用绑定的参数值做为调用参数，即调用传入参数将不起作用；如果参数绑定为`std::placeholders`，那么返回的函数对象在被调用时需要传入实时参数，参数填充的位置即由`placeholder`指定的序号。

模板2：

- `fn`：可调用的函数对象，比如函数对象、函数指针、函数引用、成员函数或者数据成员函数。
- `args`：需要绑定的函数的参数列表，使用命名空间占位符`std::placeholders::_1`，`std::placeholders::_2`标志参数，其中`std::placeholders::_1`标志为参数列表中的第一个参数，`std::placeholders::_2`标志参数列表中的第二个参数，`std::placeholders::_3`标志参数列表中的第三个参数，以此类推。

**3）举例**

```cpp
//绑定全局函数
auto newfun1 = bind(globalFun2, placeholders::_1, placeholders::_2, 98, "worker");
//相当于调用globalFun2("Lily",22, 98,"worker");
newfun1("Lily", 22);
//多传参数没有用，相当于调用globalFun2("Lucy",28, 98,"worker");
newfun1("Lucy", 28, 100, "doctor");
auto newfun2 = bind(globalFun2, "zack", placeholders::_1, 100, placeholders::_2);
//相当于调用globalFun2("zack",33,100,"engineer");
newfun2(33, "engineer");
auto newfun3 = bind(globalFun2, "zack", placeholders::_2, 100, placeholders::_1);
newfun3("coder", 33);
```

placeholders表示占位符，_1表示新生成函数的第一个参数, _2表示新生成函数的第二个参数，将这些参数传递给原函数达到占位的效果，原函数的其余参数通过bind绑定固定值。

接下来定义类

```cpp
class BindTestClass
{
public:
    BindTestClass(int num_, string name_) : num(num_), name(name_) {}
    static void StaticFun(const string &str, int age);
    void MemberFun(const string &job, int score);

public:
    int num;
    string name;
};
```

成员函数实现：

```cpp
void BindTestClass::StaticFun(const string &str, int age)
{
    cout << "this is static function" << endl;
    cout << "name is " << str << endl;
    cout << "age is " << age << endl;
}
void BindTestClass::MemberFun(const string &job, int score)
{
    cout << "this is member function" << endl;
    cout << "name is " << name << endl;
    cout << "age is " << num << endl;
    cout << "job is " << job << endl;
    cout << "score is " << score << endl;
}
```

使用bind绑定静态成员函数

```cpp
//绑定类的静态成员函数,加不加&都可以
// auto staticbind = bind(BindTestClass::StaticFun, placeholders::_1, 33);
auto staticbind = bind(&BindTestClass::StaticFun, placeholders::_1, 33);
staticbind("zack");
```

新生成的**staticbind**函数可以直接传递一个参数zack就完成了调用。接下来用bind绑定成员函数（这里是&都是取地址而不是引用）

```cpp
BindTestClass bindTestClass(33, "zack");
// 绑定类的成员函数,一定要传递对象给bind的第二个参数，可以是类对象，也可以是类对象的指针
// 如果要修改类成员，必须传递类对象的指针
auto memberbind = bind(&BindTestClass::MemberFun, &bindTestClass, placeholders::_1, placeholders::_2);
memberbind("coder", 100);

auto memberbind2 = bind(&BindTestClass::MemberFun, placeholders::_3, placeholders::_1, placeholders::_2);
memberbind2("coder", 100, &bindTestClass);
//绑定类成员时，对象必须取地址
auto numbind = bind(&BindTestClass::num, placeholders::_1);
std::cout << numbind(bindTestClass) << endl;
```

也可以用function对象接受bind返回的结果

```cpp
// function接受bind返回的函数
function< void(int, string)> funcbind = bind(globalFun2, "zack", placeholders::_1, 100, placeholders::_2);
funcbind(33, "engineer");

// function接受bind 成员函数
function< void(string, int)> funcbind2 = bind(&BindTestClass::MemberFun, &bindTestClass, placeholders::_1, placeholders::_2);
funcbind2("docker", 100);

function< void(string, int, BindTestClass *)> funcbind3 = bind(&BindTestClass::MemberFun, placeholders::_3, placeholders::_1, placeholders::_2);
funcbind3("driver", 100, &bindTestClass);

// function 直接接受成员函数,function的模板列表里第一个参数是类对象引用
function< void(BindTestClass &, const string &, int)> functomem = BindTestClass::MemberFun;
functomem(bindTestClass, "functomem", 88);

// function 绑定类的静态成员函数
function< void(const string &)> funbindstatic = bind(&BindTestClass::StaticFun, placeholders::_1, 33);
funbindstatic("Rolis");
```

## 3.5 condition_variable

[并发编程（5）——条件变量、线程安全队列 | 爱吃土豆的个人博客](https://www.aichitudou.cn/2024/11/03/并发编程（5）——条件变量、线程安全的队列/#1-条件变量)

## 3.6 右值引用

在前面已经介绍过了，这里主要说明右值引用的两大作用：

- 完美转发
- 移动语义，通过移动构造函数和移动赋值运算符，可以将临时对象的资源高效地转移到新对象中，避免不必要的拷贝。

## 3.7 智能指针

前文已介绍

## 3.8 auto和decltype 

`auto`可以让编译器在编译期就**推导出变量的类型**

1. auto的使用必须马上初始化，否则无法推导出类型
2. auto在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败
3. auto不能用作函数参数（可用模板参数代替）
4. 在类中auto不能用作非静态成员变量
5. auto不能定义数组，可以定义指针
6. auto无法推导出模板参数
7. **在不声明为引用或指针时，auto会忽略等号右边的引用类型和cv限定**
8. 在声明为引⽤或者指针时， auto会保留等号右边的引⽤和cv属性  

`decltype`获取一个**表达式的类型**，而不对表达式进行求值(类似于`sizeof`)。

`decltype`不会像auto一样忽略引用和cv属性，`decltype`会保留表达式的引用和cv属性

对于decltype(exp)有:

1. exp是表达式，decltype(exp)和exp类型相同
2. exp是函数调用，decltype(exp)和函数返回值类型相同
3. 若exp是⼀个纯右值，则返回值为 `T`  
4. 若 e 是⼀个临终值，则返回值为 `T&&`  

```cpp
int num = 10;
// 这里 decltype(num) 推导为 int 类型，因为 num 是 int 类型的普通表达式
decltype(num) anotherNum = 20; 

int add(int a, int b) { return a + b; }
// 这里 decltype(add(1, 2)) 推导为 int 类型，和 add 函数的返回值类型一致
decltype(add(1, 2)) result = add(3, 4); 

int value = 5;
int& ref = value;
// 由于 ref 是左值引用，decltype(ref) 推导为 int& 类型
decltype(ref) anotherRef = value; 

// 1 + 3 是纯右值，decltype(1 + 3) 推导为 int 类型
decltype(1 + 3) sum = 1 + 3; 

std::string str = "hello";
// std::move(str) 是临终值，decltype(std::move(str)) 推导为 std::string&& 类型
decltype(std::move(str)) movedStr = std::move(str); 
```

## 3.9 泛化的常量表达式  

```cpp
int N = 5;
int arr[N]
```

该段代码是错的，N是一个变量，我们不能使用一个变量来为数组开辟一个确定大小的空间，因为这个变量的值随时都可以变，不能用做一个确定的对象。我们需要声明为 `const int N = 5` 才可以 。

我们也可以通过泛化常数来解决：

```cpp
constexpr int N = 5; // N
int arr[N]; // OK
```

`constexpr` 告诉编译器这是⼀个编译期常量，**甚至可以把一个函数声明为编译期常量表达式**。  

```cpp
constexpr int getFive(){ return 5; }
int arr[getFive() + 1];
```

## 3.10 nullptr

`nullptr`是用来代替`NULL`，一般C++会把NULL、0视为同一种东西，这取决去编译器如何定义NULL，有的定义为`((void&)0)`，有的定义为0.

C++不允许直接将`void*`**隐式**转换到其他类型，在进行C++**重载**时会发生混乱。

比如，我们想要重载 foo 函数：

```cpp
void foo(char *);
void foo(int );
```

在代码中使用 `NULL` 时会出现一些问题。在某些实现里，`NULL` 被定义为 `((void*)0)` 。当我们编写 `char *ch = NULL;` 这样的代码时，`NULL` 实际上会被当作 0 来处理。而当调用 `foo(NULL)` 时，由于此时 `NULL` 等同于 0，编译器会选择调用 `foo(int)` 这个重载版本，这就可能导致代码的行为与预期不符，产生混淆。

为了解决这个问题，C++11 引入了 `nullptr` 关键字。`nullptr` 的出现是**为了清晰地区分空指针和整数 0**。`nullptr` 的类型是 `nullptr_t`，它具有很好的兼容性，**能够隐式转换为任何指针类型或者成员指针类型**。同时，`nullptr` **也可以进行相等或不等的比较操作**。所以，在需要使用空指针的场景下，建议用 `nullptr` 来替代 `NULL`，这样可以避免因 `NULL` 带来的类型匹配歧义问题。例如，调用 `foo(nullptr)` 时，编译器会明确地将 `nullptr` 当作空指针来处理，从而调用 `foo(char *)` 版本的函数，让代码的行为更加明确和可预期。

## 3.11 并行

并行也是C++11新特性，包括std::thread、std::async、std::future以及各种锁。

# 4. STL容器

## 4.1 基础知识

### 4.1.1 什么是STL，包含哪些组件  

**广义上讲**，STL分为3类：Algorithm(算法)、Container(容器)和lterator(迭代器)，容器和算法通过迭代器可以进行无缝地连接。

**详细的说**，STL由6部分组成：容器(Container)、算法(Algorithm)、迭代器(lterator)、仿函数(Functionobject)、适配器(Adaptor)、空间配制器(Allocator)。

STL六大组件的交互关系：

1. 容器通过空间配置器取得数据存储空间
2. 算法通过迭代器存储容器中的内容
3. 仿函数可以协助算法完成不同的策略的变化
4. 适配器可以修饰仿函数。

STL六大组件的介绍：

- 容器：各种数据结构，如`vector`、`list`、`deque`、`set`、`map`等，用来存放数据，从实现角度来看，STL容器是一种`模板类`。

- 算法：各种常用的算法，如`sort`、`find`、`copy`、`for_each`。从实现的角度来看，STL算法是一种`模板函数`。

- 迭代器：扮演了容器与算法之间的胶合剂，共有**五种类型**，从实现角度来看，迭代器是一种将`operator*`，`operator->`，`operator++`，`operator-`等指针相关操作予以重载的模板类。

  所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(`int*`、`double*`)也是一种迭代器。

- 仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了`operator()`的class 或者classtemplate

- 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。STL提供的`queue` 和 `stack`，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助`deque`，所有操作都由底层的deque供应。

- 空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的模板类。一般的分配器的`std:alloctor`都含有两个函数`allocate`与`deallocte`，这两个函数分别调用`operator new(`)与`delete()`，这两个函数的底层又分别是`malloc(and free();`但是每次`maloc`会带来格外开销

![image-20250227102020490](/images/$%7Bfiilename%7D/image-20250227102020490.png)

### 4.1.2 常见的容器

STL容器分为序列式容器和关联式容器，如下图所示：

![image-20250227102217474](/images/$%7Bfiilename%7D/image-20250227102217474.png)

序列容器：

- vector(向量)： `std::vector` 是一个动态数组实现，提供高效的随机访问和在尾部进行插入/删除操作。是动态空间，随着元素的加入，它的内部机制会**自行扩充**空间以容纳新元素。vector 维护的是一个**连续**的线性空间，而且普通指针就可以满足要求作为vector的迭代器。

  扩充的过程并不是直接在原有空间后面追加容量，而是重新申请一块连续空间，将原有的数据拷贝到新空间中，再释放原有空间，完成一次扩充。需要注意的是，每次扩充是重新开辟的空间，所以扩充后，原有的迭代器将会失

- list(链表)： `std::list` 是一个**双向链表**实现，支持在任意位置进行插入/删除操作，但不支持随机访问。

  与 vector 相比，list 的好处就是每次插入或删除一个元素，就配置或释放一个空间，而且原有的迭代器也不会失效。list 是一个双向链表，普通指针已经不能满足 list 迭代器的需求，因为 list 的存储空间是**不连续**的。list 的迭代器必需具备前移和后退功能，所以list 提供的是 Bidirectionallterator。list 的数据结构中只要一个指向 node节点的指针就可以了。

- deque(双端队列)： `std::deque` 是一个**双端队列**实现，允许在两端进行高效插入/删除操作。

  vector 是**单向开口**的连续线性空间，deque 则是一种**双向开口**的**连续**线性空间。所谓双向开口，就是说 deque 支持从头尾两端进行元素的插入和删除操作。相比于 vector 的扩充空间的方式，deque 实际上更加贴切的实现了动态空间的概念。deque 没有容量的概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并连接起来，代价是复杂的迭代器结构，除非必要，应该尽可能的使用 vector。

- array(数组)：`std::array` 是一个固定大小的数组实现，提供对数组元素的高效随机访问。

- forward_list(前向链表)：`std::forward 1ist` 是一个**单向链表**实现，只能从头到尾进行遍历，不支持双向访问。

关联容器：

- set(集合)：`std::set` 是一个有序的集合，不允许重复元素，支持快速查找、插入和删除。
- multiset(多重集合)：`std::multiset`是一个有序的多重集合，允许重复元素。
- map(映射)： `std::map` 是一个有序的键值对集合，不允许重复的键，支持快速查找、插入和删除。
- multimap(多重映射)：`std::multimap` 是一个有序的多重映射，允许重复的键。
- unordered set(无序集合)： `std::unordered set` 是一个无序的集合，不允许重复元素，支持快速查找、插入和删除。
- unordered multiset(无序多重集合)： `std::unordered multiset` 是一个无序的多重集合，允许重复元素。
- unordered map(无序映射)： `std::unordered map` 是一个无序的键值对集合，不允许重复的键，支持快速
  查找、插入和删除。
- unordered_multimap(无序多重映射)： `std::unordered multimap` 是一个无序的多重映射，允许重复的键。

容器适配器：虽然它不是容器，但它底层是依靠容器实现的

- stack(栈)：`std::stack`是一个基于底层容器的栈实现，默认使用`std::deque`。

  是一种先进后出的数据结构，只有一个出口，stack 允许从最顶端新增元素，移除最顶端元素，取得最顶端元素。deque 是双向开口的数据结构，所以使用 deque 作为底部结构并**封闭其头端开口**，就形成了一个 stack。

- queue(队列)：`std::queue`是一个基于底层容器的队列实现，默认使用`std::queue`。

  是一种**先进先出**的数据结构，有两个出口，允许从**最底端加入元素**，**取得最顶端元素**，从最底端新增元素，从最顶端移除元素。deque 是双向开口的数据结构，若以 deque 为底部结构并**封闭其底端的出口，和头端的入口**，就形成了一个 queue。(其实 list 也可以实现 deque)

- priority_queue(优先队列): `std::priority_queue` 是一个基于底层容器的优先队列实现，默认使用`std::vector` 。`priority_queue` 允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高(数值最高)的元素开始取。

## 4.2 STL空间配置器

大家好，我是小贺。

### 4.2.1 前言

天下大事，必作于细。

源码之前，了无秘密。

你清楚下面这几个问题吗？

- 调用 new 和 delete 时编译器底层到底做了哪些工作？
- STL 器底层空间配置原理是怎样的？
- STL 空间配置器到底要考虑什么？
- 什么是内存的配置和释放？

这篇，我们就来回答这些问题。

![](/images/$%7Bfiilename%7D/STL-allocation-mindnode.png)  

### 4.2.2 STL 六大组件

在深入配置器之前，我们有必要了解下 STL 的背景知识：

标准模板库（英文：Standard Template Library，缩写：STL），是一个 C++ 软件库。

STL 的价值在于两个方面，就底层而言，STL 带给我们一套极具实用价值的零部件以及一个整合的组织；除此之外，STL 还带给我们一个高层次的、以泛型思维 (Generic Paradigm) 为基础的、系统化的“软件组件分类学”。

STL 提供六大组件，了解这些为接下来的阅读打下基础。

- 容器（containers）：各种数据结构，如 vector, list, deque, set, map 用来存放数据。从实现的角度来看，STL 容器是一种 class template。

- 算法（algorithms）：各种常用的算法如 sort, search, copy, erase…从实现角度来看，STL 算法是一种 function template。

- 迭代器（iterators）：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”。从实现角度来看，迭代器是一种将 operator *, operator ->, operator++, operator– 等指针相关操作予以重载的class template。

- 仿函数（functors）：行为类似函数，可以作为算法的某种策略。从实现角度来看，仿函数是一种重载了 operator() 的 class 或class template。

- 适配器（adapters）：一种用来修饰容器或仿函数或迭代器接口的东西。例如 STL 提供的 queue 和 stack，虽然看似容器，其实只能算是一种容器适配器，因为它们的底部完全借助 deque，所有操作都由底层的 deque 供应。

- 配置器（allocator）：负责空间配置与管理，从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。

![](/images/$%7Bfiilename%7D/stl-six-component.png)

### 4.2.3 何为空间配置器

**3.1 为何需要先了解空间配置器？**

从使用 STL 层面而言，空间配置器并不需要介绍 ，因为容器底层都给你包装好了，但若是从 STL 实现角度出发，空间配置器是首要理解的。

作为 STL 设计背后的支撑，空间配置器总是在默默地付出着。为什么你可以使用算法来高效地处理数据，为什么你可以对容器进行各种操作，为什么你用迭代器可以遍历空间，这一切的一切，都有“空间配置器”的功劳。

**3.2 SGI STL 专属空间配置器**

SGI STL 的空间配置器与众不同，且与 STL 标准规范不同。

其名为 alloc，而非 allocator。

虽然 SGI 也配置了 allocatalor，但是它自己并不使用，也不建议我们使用，原因是效率比较感人，因为它只是在基层进行配置/释放空间而已，而且不接受任何参数。

SGI STL 的每一个容器都已经指定缺省的空间配置器是 alloc。

![](/images/$%7Bfiilename%7D/alloc-0001.png)

在 C++ 里，当我们调用 new 和 delete 进行对象的创建和销毁的时候，也同时会有内存配置操作和释放操作:

这其中的 new 和 delete 都包含两阶段操作：

- 对于 new 来说，编译器会先调用 ::operator new 分配内存；然后调用 Obj::Obj() 构造对象内容。

- 对于 delete 来说，编译器会先调用 Obj::~Obj() 析构对象；然后调用  ::operator delete 释放空间。

为了精密分工，STL allocator 决定将这两个阶段操作区分开来。

- 对象构造由 ::construct() 负责；对象释放由 ::destroy() 负责。

- 内存配置由 alloc::allocate() 负责；内存释放由 alloc::deallocate() 负责；

STL配置器定义在 <memory> 中，下图直观的描述了这一框架结构

![memory](/images/$%7Bfiilename%7D/memory.png)

### 4.2.4 构造和析构源码

我们知道，程序内存的申请和释放离不开基本的构造和析构基本工具：construct() 和 destroy() 。 

在 STL 里面，construct() 函数接受一个指针 P 和一个初始值 value，该函数的用途就是将初值设定到指针所指的空间上。

destroy() 函数有两个版本，第一个版本接受一个指针，准备将该指针所指之物析构掉。直接调用析构函数即可。

第二个版本接受 first 和 last 两个迭代器，将[first,last)范围内的所有对象析构掉。

![](/images/$%7Bfiilename%7D/con-and-destory.png)

其中 destroy() 只截取了部分源码，全部实现还考虑到特化版本，比如判断元素的数值类型 (value type) 是否有 trivial destructor 等限于篇幅，完整代码请参阅《STL 源码剖析》。

再来张图吧，献丑了。

![](/images/$%7Bfiilename%7D/con-and-destory2.png)

### 4.2.5 内存的配置与释放

前面所讲都是对象的构造和析构，接下来要讲的是对象构造和析构背后的故事—（内存的分配与释放），这块是才真正的硬核，不要搞混了哦。

**5.1 真· alloc 设计奥义**

对象构造和析构之后的内存管理诸项事宜，由 <stl_alloc.h> 一律负责。SGI 对此的设计原则如下：

- 向 system heap 要求空间

- 考虑多线程 (multi-threads) 状态

- 考虑内存不足时的应变措施

- 考虑过多“小型区块”可能造成的内存碎片 (fragment) 问题

考虑到小型区块可能造成的内存破碎问题，SGI 为此设计了双层级配置器。当配置区块超过 128bytes 时，称为足够大，使用第一级配置器，直接使用 malloc() 和 free()。

当配置区块不大于 128bytes 时，为了降低额外负担，直接使用第二级配置器，采用复杂的 memory pool 处理方式。

无论使用第一级配接器（__malloc_alloc_template）或是第二级配接器（__default_alloc_template），alloc 都为其包装了接口，使其能够符合 STL 标准。
![](/images/$%7Bfiilename%7D/alloc-0002.png)

其中， __malloc_alloc_template 就是第一级配置器;

__default_alloc_template 就是第二级配置器。

这么一大堆源码看懵了吧，别着急，请看下图。

![](/images/$%7Bfiilename%7D/alloc-0003.png)

其中 SGI STL 将配置器多了一层包装使得 Alloc 具备标准接口。

![](/images/$%7Bfiilename%7D/alloc-0004.png)

### 4.2.6 alloc 一级配置器源码解读

这里截取部分（精华）解读

（1）第一级配置器以 malloc(), free(), realloc() 等 C 函数执行实际的内存配置、释放和重配置操作，并实现类似 C++ new-handler 的机制（因为它并非使用 ::operator new 来配置内存，所以不能直接使用C++ new-handler 机制）。

（2）SGI 第一级配置器的 allocate() 和 reallocate() 都是在调用malloc() 和 realloc() 不成功后，改调用 oom_malloc() 和oom_realloc()。

![](/images/$%7Bfiilename%7D/alloc-0005.png)

（3）oom_malloc() 和 oom_realloc() 都有内循环，不断调用“内存不足处理例程”，期望某次调用后，获得足够的内存而圆满完成任务，哪怕有一丝希望也要全力以赴申请啊，如果用户并没有指定“内存不足处理程序”，这个时候便无力乏天，真的是没内存了，STL 便抛出异常。或调用exit(1) 终止程序。

![](/images/$%7Bfiilename%7D/alloc-0006.png)

### 4.2.7 alloc 二级配置器源码解读

照例，还是截取部分（精华）源码解读。看累了嘛，远眺歇会，回来继续看，接下来的这部分，将会更加的让我们为大师的智慧折服！

第二级配置器多了一些机制，专门针对内存碎片。内存碎片化带来的不仅仅是回收时的困难，配置也是一个负担，额外负担永远无法避免，毕竟系统要划出这么多的资源来管理另外的资源，但是区块越小，额外负担率就越高。

![](/images/$%7Bfiilename%7D/alloc-0007.png)

**7.1 SGI 第二级配置器到底解决了多少问题呢？**

简单来说 SGI第二级配置器的做法是：sub-allocation （层次架构）：

前面也说过了，SGI STL 的第一级配置器是直接使用 malloc()， free(), realloc() 并配合类似 C++ new-handler 机制实现的。第二级配置器的工作机制要根据区块的大小是否大于 128bytes 来采取不同的策略：

![](/images/$%7Bfiilename%7D/alloc-0008.png)

继续跟上节奏，上面提到了 memory pool ，相信程序员朋友们很熟悉这个名词了，没错，这就是二级配置器的精髓所在，如何理解？请看下图：

![](/images/$%7Bfiilename%7D/alloc-0009.png)

有了内存池，是不是就可以了，当然没有这么简单。上图中还提到了自由链表，这个又是何方神圣？

我们来一探究竟！

**7.2 自由链表自由在哪？又该如何维护呢？**

我们知道，一方面，自由链表中有些区块已经分配给了客端使用，所以 free_list 不需要再指向它们；另一方面，为了维护 free-list，每个节点还需要额外的指针指向下一个节点。

那么问题来了，如果每个节点有两个指针？这不就造成了额外负担吗？本来我们设计 STL 容器就是用来保存对象的，这倒好，对象还没保存之前，已经占据了额外的内存空间了。那么，有方法解决吗？当然有！再来感受一次大师的智慧！

（1）在这之前我们先来了解另一个概念——union（联合体/共用体），对 union 已经熟悉的读者可以跳过这一部分的内容；如果忘记了也没关系，趁此来回顾一下：

（a）共用体是一种特殊的类，也是一种构造类型的数据结构。

（b）共用体表示几个变量共用一个内存位置，在不同的时间保存不同的数据类型和不同长度的变量。

（c）所有的共用体成员共用一个空间，并且同一时间只能储存其中一个成员变量的值。例如如下：

![union](/images/$%7Bfiilename%7D/union.png)

一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长度是 double 类型，

所以 ChannelManager 的空间大小就是 double 数据类型的大小。在 C++ 里，union 的成员默认属性页为 public。union 主要用来压缩空间，如果一些数据不可能在同一时间同时被用到，则可以使用 union。

（2）了解了 union 之后，我们可以借助 union 的帮助，先来观察一下 free-list 节点的结构

![](/images/$%7Bfiilename%7D/obj02.png)

来深入了解 free_list 的实现技巧，请看下图。

![](/images/$%7Bfiilename%7D/obj03.png)

在 union obj 中，定义了两个字段，再结合上图来分析：

从第一个字段看，obj 可以看做一个指针，指向链表中的下一个节点；

从第二个字段看，obj 可以也看做一个指针，不过此时是指向实际的内存区。

一物二用的好处就是不会为了维护链表所必须的指针而造成内存的另一种浪费，或许这就是所谓的自由奥义所在！大师的智慧跃然纸上。

**7.3 第二级配置器的部分实现内容**

到这里，我们已经基本了解了第二级配置器中 free_list 的工作原理了。附上第二级配置器的部分实现内容源码：

![](/images/$%7Bfiilename%7D/free-list01.png)

太长了吧，看懵逼了，没关系，请耐心接着往下看。

### 4.2.8 空间配置器函数allocate源码解读

我们知道第二级配置器拥有配置器的标准接口函数 allocate()。此函数首先判断区块的大小，如果大于 128bytes –> 调用第一级配置器；小于128bytes–> 就检查对应的 free_list（如果没有可用区块，就将区块上调至 8 倍数的边界，然后调用 refill(), 为 free list 重新填充空间。

**8.1 空间申请**

调用标准接口函数 allocate()：

![](/images/$%7Bfiilename%7D/alloc-0010.png)

![](/images/$%7Bfiilename%7D/alloc-0011.png)

NOTE：每次都是从对应的 free_list 的头部取出可用的内存块。然后对free_list 进行调整，使上一步拨出的内存的下一个节点变为头结点。

**8.2 空间释放**

同样，作为第二级配置器拥有配置器标准接口函数 deallocate()。该函数首先判断区块大小，大于 128bytes 就调用第一级配置器。小于 128 bytes 就找出对应的 free_list，将区块回收。

![](/images/$%7Bfiilename%7D/alloc-0012.png)

NOTE：通过调整 free_list 链表将区块放入 free_list 的头部。

区块回收纳入 free_list 的操作，如图所示：

**8.3 重新填充 free_lists**

（1）当发现 free_list 中没有可用区块时，就会调用 refill() 为free_list 重新填充空间；

（2）新的空间将取自内存池（经由 chunk_alloc() 完成）；

（3）缺省取得20个新节点（区块），但万一内存池空间不足，获得的节点数可能小于 20。

![](/images/$%7Bfiilename%7D/alloc-0013.png)

**8.4 内存池（memory pool）**

唔…在前面提到了 memory pool，现在终于轮到这个大 boss 上场。

首先，我们要知道从内存池中取空间给 free_list 使用，是 chunk_alloc() 在工作，它是怎么工作的呢？

我们先来分析 chunk_alloc() 的工作机制：

chunk_alloc() 函数以 end_free – start_free 来判断内存池的“水量”（哈哈，很形象的比喻）。

具体逻辑都在下面的图里了，很形象吧。

![](/images/$%7Bfiilename%7D/mem-pool001.png)

如果第一级配置器的 malloc() 也失败了，就发出 bad_alloc 异常。

说了这么多来看一下 STL 的源码吧。

![](/images/$%7Bfiilename%7D/mem-pool002.png)
太长了，又看懵逼了吧，没关系，请看下图。

![](/images/$%7Bfiilename%7D/mem-pool003.png)

NOTE：上述就是 STL 源码当中实际内存池的操作原理，我们可以看到其实以共用体串联起来共享内存形成了 free_list 的实质组成。





## 4.2 面试知识

### 4.2.1 push_back和emplace_back

`push_back` 和 `emplace_back` 是 C++ 标准库容器（如 `std::vector`、`std::list`、`std::deque` 等）提供的用于在容器**尾部**添加元素的成员函数。

`push_back`：

- 当使用 `push_back` 时，需要先在容器外部创建一个对象，然后将这个对象传递给 `push_back` 函数。如果传递的是左值，会调用拷贝构造函数将对象复制到容器中；如果传递的是右值，会调用移动构造函数将对象移动到容器中。**相当于连续创建了两个内容相同但地址不同的对象**，一个在外部用于给容器提供拷贝构造或赋值运算符的参数对象，一个在内部。
- 在添加对象时可能会涉及到拷贝或移动操作，尤其是对于大型对象，这些操作会带来一定的性能开销。可能会因为内存不够而抛出异常。

`emplace_back`：

- `emplace_back` 会直接在容器的内存空间中调用对象的构造函数进行对象的构造，它接收构造对象所需的参数，然后在容器内部原地构造对象，避免了不必要的拷贝或移动操作。
- 由于直接在容器内部构造对象，避免了拷贝或移动操作，因此在性能上通常更优，特别是对于需要动态分配内存的对象。且因为容器内部已经开辟好内存了，不会因为内存原因抛出异常。

**举例：**

```cpp
class MyClass {
public:
    MyClass(int value, const std::string& str) : data(value), text(str)；
    MyClass(const MyClass& other) : data(other.data), text(other.text)；
    MyClass(MyClass&& other) noexcept : data(other.data), text(std::move(other.text))；
private:
    int data;
    std::string text;
};

int main() {
    std::vector<MyClass> vec;
    // 使用 push_back 添加左值
    MyClass obj(1, "Hello");
    std::cout << "Using push_back with lvalue:" << std::endl;
    vec.push_back(obj);
    
    // 使用 push_back 添加右值
    std::cout << "\nUsing push_back with rvalue:" << std::endl;
    vec.push_back(MyClass(2, "World"));

    // 使用 emplace_back
    std::cout << "\nUsing emplace_back:" << std::endl;
    vec.emplace_back(3, "C++");

    return 0;
}
```

- **使用 `push_back` 添加左值**：先创建对象 `obj`，然后调用 `push_back` 时会调用拷贝构造函数将 `obj` 复制到容器中。
- **使用 `push_back` 添加右值**：直接传递临时对象 `MyClass(2, "World")` 给 `push_back`，会调用移动构造函数将临时对象移动到容器中。
- **使用 `emplace_back`**：直接传递构造对象所需的参数 `3` 和 `"C++"` 给 `emplace_back`，它会在容器内部原地调用构造函数构造对象，不会触发拷贝或移动构造函数。
