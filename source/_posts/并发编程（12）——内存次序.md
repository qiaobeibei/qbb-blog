---
title: 并发编程（12）——内存次序
date: 2024-11-21 21:35:35
categories:
- C++
- 并发编程
tags: 
- 宽松次序
- 先后一致次序
- 获取-释放次序
typora-root-url: ./..
---



# 十二、day12

在前两节中（[并发编程（10）](https://www.aichitudou.cn/2024/11/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%8810%EF%BC%89%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/#2-3-%E5%86%85%E5%AD%98%E6%AC%A1%E5%BA%8F)和并发编程（11）），我们简单学习了有关内存次序的六种内存次序和三种内存模型，并对C++同步和先行关系进行了详细的了解。今天学习六种内存序的使用方法以及三种模型是如何实现的。简单回顾一下上上节中我们解到的知识：

1. 内存次序操作包括顺序一致性、强制顺序、弱顺序；
2. 枚举类`std::memory_order`中定义了六种宏，方便我们在使用原子类型操作时将其作为额外参数加入；
3. 六种内存序按原子类型的操作被划分为：存储操作，载入操作，“读改写”操作；
4. 六种内存序相互组合可以实现三种顺序模型：`Sequencial consistent ordering`、`Acquire-release ordering`、`Relaxed ordering`。
5. 六种内存序可以分为三类（不是根据原子操作的类型分的）：宽松次序（memory_order_relaxed）、先后一致次序（memory_order_seq_cst）、获取-释放次序（剩余四种）

接下来对内存次序和内存模型的实现进行详细分析。

参考：

1. [博主恋恋风辰的个人博客](https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2WyPSKn5SVHAMVwFrQkCnyGn1kF)
2. [up主mq白cpp的个人仓库](https://github.com/Mq-b/ModernCpp-ConcurrentProgramming-Tutorial/blob/main/md/%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/03async%E4%B8%8Efuture%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md)



# 1. 宽松次序

## 1.1 CPU 内存结构

一个简单的四核CPU内存结构示意图如下所示：

![https://cdn.llfc.club/1697539893049.jpg](/images/$%7Bfiilename%7D/1697539893049.jpg)

<center>图片来源：https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2WyQINuJWuRa8CwBM0VOh4kzxkj</center>

CPU 和内存之间通过三级缓存（StoreBuffer、Cache、Memory）进行数据交互，CPu每个核都有自己的缓存区`StoreBuffer`，对其他核**不可见**。但是每两个核组成一个`Bank`，每个`Bank`共享一个`Cache`缓存区，每个Bank中的核可以将缓存区`StoreBuffer`中的数据写入至`Cache`，这样两个核之间的数据就可以进行交互。每四个核又有一个缓存区`Memory`，每个`Bank`可以将自己的`Cache`写入至`Memory`，这样两个`Bank`，即四个核就可以进行数据交互。

如果多个核对同一个快缓存区的数据进行修改，比如对Cache缓存区中的变量a进行值修改，可能会造成数据竞争，那该如何保证数据一致性？这就要提及**MESI一致性协议**。

MESI 协议，是一种叫作写失效（Write Invalidate）的协议。在写失效协议里，**只有一个** CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个 CPU 核心写入 cache 之后，它会去广播一个“失效”请求告诉所有其他的 CPU 核心。

MESI 协议对应的四个不同的标记，分别是：

- **M**：代表已修改（Modified），用来告诉其他核已经修改完成，其他核可以向cache中写入数据。
- **E**：代表独占（Exclusive），表示数据只是加载到当前 CPU核 自己的store buffer中，其他的核并没有加载对应的数据到自己的 store buffer 里。这个时候，如果要向独占的 store buffer 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。
- **S**：代表共享（Shared），共享状态就是在多核中同时加载了同一份数据。所以在共享状态下想要修改数据要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的 cache ，都变成无效的状态，然后再更新当前 cache 里面的数据。
- **I**：代表已失效（Invalidated）

我们可以这么理解，如果变量a此刻存在于各个核的`StoreBuffer`中，那么CPU1核修改这个a的值，放入`cache`时通知其他CPU核写失效，因为同一时刻仅有一个CPU核可以写数据，但是其他CPU核是可以读数据的，那么其他核读到的数据可能是CPU1核修改之前的。



## 3.2 std::memory_order_relaxed

我们从最简单的内存序（std::memory_order_relaxed）开始学习六种内存序。

`std::memory_order_relaxed`有以下几个功能：

1. 作用于原子变量（利用操作不可分割的特性）。

2. 原子类型上的操作**不存在**同步关系（synchronizes-with），即不会隐式地向其他线程传播**可见性**或**顺序性**信息。线程间仅存的共有信息是每个变量的改动序列。

   ```cpp
   std::atomic<int> x{0};
   std::atomic<int> y{0};
   
   void thread1() {
       x.store(1, std::memory_order_relaxed);
       y.store(2, std::memory_order_relaxed);
   }
   
   void thread2() {
       int a = y.load(std::memory_order_relaxed);
       int b = x.load(std::memory_order_relaxed);
       std::cout << a << " " << b << std::endl;
   }
   ```

   在 `thread2` 中，`a` 和 `b` 的值可能会以任何顺序出现（包括 `a=2, b=0` 或 `a=0, b=1`），因为操作之间没有同步关系。

3. 在单线程中，同一个变量上的操作严格服从先行关系，但不同变量不具有先行关系，可以**乱序执行**（因为 relaxed 模式不会对指令的全局顺序作任何保证，**编译器会对代码进行优化**和**CPU 对指令重排**）。

4. 多线程下**不存在**先行关系（可见性），换句话说，`relaxed` 模式不保证某个线程对原子变量的写入对其他线程的读操作**立即可见**，可能得过一会儿后，其他 线程才能读到原子变量更新后的值。



综上，对该内存序的唯一要求是：在一个线程中，如果某个表达式已经看到原子变量某时刻持有的值a，则该表达式的后续表达式只能看到a或者比a更新的值。

我们可以通过两个线程说明，采用宽松次序的操作能宽松到什么程度，代码如下：

```cpp
std::atomic<bool> x, y;
std::atomic<int> z;

void write_x_then_y() {
    x.store(true, std::memory_order_relaxed);  // 1
    y.store(true, std::memory_order_relaxed);  // 2
}

void read_y_then_x() {
    while (!y.load(std::memory_order_relaxed)) { // 3
        std::cout << "y load false" << std::endl;
    }
    if (x.load(std::memory_order_relaxed)) { //4
        ++z;
    }
}

int main(){
    x=false;
    y=false;
    z=0;
    std::thread t1(write_x_then_y);
    std::thread t2(read_y_then_x);
    t1.join();
    t2.join();
    assert(z.load() != 0); // 5
}
```

我们启动了两个线程`t1`和`t2`，分别调用 `write_x_then_y()` 和 `read_y_then_x()` ，前者将原子变量`x`和`y`的值通过原子操作`store`修改为`true`；后者通过判断`x`和`y`的值执行相关的操作。

- 在理想情况下，线程t1执行的任务会将原子变量x和y**按顺序**置为true，从而在线程t2执行的任务中，将z的值++，主函数断言成功，z确实不为0，程序不报错。
- 但是还有一种情况，**2 处先于 1 处执行**，那么此时在 t2 任务中， y为true跳出循环，但是x仍然为 false，z不++，导致断言失败，程序报错。

我们还可以从以下两个角度分析：

1. **从cpu架构分析**

假设线程 t1 运行在 核1上，t2 运行在 核3上，那么 t1 对x和y的操作，t2 是看不到的（如果t1没将数据写入至Memory中）。比如当线程t1运行至1处将x设置为true，t1运行至2处将y设置为true。这些操作仅在核1的store buffer中，还未放入cache和memory中，核3 自然不可见。

如果 核1 先将y放入memory，那么核3就会读取y的值为true。那么t2就会运行至3处从while循环退出，进而运行至4处，此时核1还未将x的值写入memory。t2读取的x值为false，进而线程t2运行结束，然后核1将x写入true， t1结束运行，最后主线程运行至5处，因为z为0,所以触发断言。

![https://cdn.llfc.club/1697539893049.jpg](/images/$%7Bfiilename%7D/1697539893049.jpg)

2. **从宽松内存序分析**

因为`memory_order_relaxed`是宽松的内存序列，它**只保证操作的原子性，并不能保证多个变量之间的顺序性**，也不能保证同一个变量在不同线程之间的可见顺序。

比如t1可能先运行2处代码再运行1处代码，因为我们的代码会被编排成指令执行，编译器在不破坏语义的情况下(2处和1处代码无耦合，可调整顺序)，2可能先于1执行。如果这样，t2运行至3处退出while循环，继续运行4处，此时t1还未执行1初代码，则t2运行4处条件不成立不会对z做增加，t2结束。这样也会导致z为0引发断言。

------

还有一个涉及1个原子变量和4个线程的例子：

```cpp
void TestOderRelaxed2() {
    std::atomic<int> a{ 0 };
    std::vector<int> v3, v4;
        std::thread t1([&a]() { // 存储偶数
            for (int i = 0; i < 10; i += 2) {
                a.store(i, std::memory_order_relaxed);
            }    
        });
        std::thread t2([&a]() { // 存储奇数
            for (int i = 1; i < 10; i += 2)
                a.store(i, std::memory_order_relaxed);
            });
        std::thread t3([&v3, &a]() {
            for (int i = 0; i < 10; ++i)
                v3.push_back(a.load(std::memory_order_relaxed));
            });
        std::thread t4([&v4, &a]() {
            for (int i = 0; i < 10; ++i)
                v4.push_back(a.load(std::memory_order_relaxed));
            });
        t1.join();
        t2.join(); 
        t3.join(); 
        t4.join();
        for (int i : v3) {
            std::cout << i << " ";
        }
        std::cout << std::endl;
        for (int i : v4) {
            std::cout << i << " ";
        }
        std::cout << std::endl;
}
```

我们创建了一个类型为atomic＜int>的变量a，两个vector容器v3和v4以及4个线程t1、t2、t3、t4。

线程t1向原子变量`a`中存储偶数，线程t2向a中存储奇数，线程t3从原子变量`a`中读取数据写入v3中，线程t4从原子变量`a`中读取数据写入v4中。这四个线程并发执行，最后打印v3和v4的数据。

> [运行](https://godbolt.org/)代码

因为`memory_order_relaxed`不保证顺序性和可见性：

- **顺序性**：`t1` 和 `t2` 写入的顺序未定义，可能会交错。
- **可见性延迟**：`t3` 和 `t4` 读取的值不一定是最新的值（可能滞后）。

如果机器性能足够好，`t1` 和 `t2` 执行完所有写入操作时（最后一次是线程t2写入奇数9），`t3` 和 `t4` 才开始读取，那么 `a` 的最终值已经是 `9`，因此 `t3` 和 `t4` 的所有读取结果都会是 `9`。我们看到的可能是这种输出

```
v3: 9 9 9 9 9 9 9 9 9 9
v4: 9 9 9 9 9 9 9 9 9 9
```

如果 `t1` 和 `t2` 与 `t3` 和 `t4` 并发执行，那么 `t3` 和 `t4` 在读取 `a` 的值时，可能捕捉到某些时刻的中间状态，导致 `v3` 和 `v4` 中的值看起来是乱序的。也可能是这种

```
v3: 0 1 7 6 8 9 9 9 9 9 
v4: 0 2 1 4 5 7 6 8 9 9
```

但我们能确定的是如果v3中7先于6，8，9等，那么v4中也是7先于6，8，9。

因为多个线程仅操作了a变量，通过`memory_order_relaxed`的方式仅能保证对a的操作是原子的（同一时刻仅有一个线程写a的值，但是可能多个线程读取a的值）。

但是**多个线程之间操作不具备同步关系，自然也就构成不了先行关系，那么多个线程之间就不存在可见性**。也就是线程t1将a改为7，那么线程t3不知道a改动的最新值为7，它读到a的值为1。只是要过一阵子可能会读到7或者a变为7之后又改动的其他值。

但是t3,t4两个线程读取a的次序是一致的，比如t3和t4都读取了7和9，t3读到7在9之前，那么t4也只能读取到7在9之前。因为我们`memory_order_relaxed`保证了多线程对同一个变量的原子操作的安全性，不同线程读取该原子变量的值，要么读到旧值要么读到新值，只不过新值**可见性会有延迟**。

------

```cpp
void TestOrderRelaxed() {
    std::atomic<bool> rx, ry;
    std::thread t1([&]() {
        rx.store(true, std::memory_order_relaxed); // 1
        ry.store(true, std::memory_order_relaxed); // 2
        });
    std::thread t2([&]() {
        while (!ry.load(std::memory_order_relaxed)); //3
        assert(rx.load(std::memory_order_relaxed)); //4
        });
    t1.join();
    t2.join();
}
```

上面的代码在一定程度上会触发断言4。因为线程 t1 执行完 1，2之后，有可能2操作的结果先放入内存中被t2看到（memory_order_relaxed无先行关系，自然变量存入内存的顺序也不能保证顺序），此时t2执行退出3循环进而执行4，此时t2看到的rx值为false触发断言。

我们称2和3不构成同步关系， 2 “ not synchronizes with “ 3

**如果**能保证2的结果立即被3看到, 那么称 2 “synchronizes with “ 3（但在memory_order_relaxed中，**不可能**存在同步关系）。

**如果 **2 同步于 3还有一层意思就是，如果在线程t1 中 1 顺序先于 2(sequence before)， 那么 1先行于3。那我们可以理解t2执行到3处时，可以获取到t1执行1操作的结果，也就是rx为true。t2线程中3顺序先于4（sequence before），那么1 操作自然也先行于 4。也就是1 操作的结果可以立即被4获取。进而不会触发断言（上述过程的推演都基于先行关系的**延续性**）。

------

`std::memory_order_relaxed` 的特点是：

- 提供最小的内存序约束，仅保证操作的原子性，而不保证同步性或可见性。
- **适用场景**：当同步关系或先行关系不是关键需求，而只需利用原子性来避免数据竞争的场景。
- 适用操作：读（`load`）、写（`store`）、读改写（`read-modify-write`）





先后一致次序



怎样保证2 同步于 3 是解决问题的关键， 我们引入 Acquire-Release 内存顺序
